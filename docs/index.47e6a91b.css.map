{"mappings":"ACyCA,+BAGA,uFAGA,2DAIA,wFAGA,sKASA,iECmpEA,iBAGA,iCAIA,8CAGA,uBAGA,wDAKA,kCAGA,iCAGA,0DAKA,mDAIA,4CAGA,yDAIA,sDAIA,8BAGA,oDAGA,qFAOA,yDAOA,2FAIA,2DAKA,gDAGA,yCAEE,2BAGA,8FAGA,yDAEF,qEAGA,0BAGA,sDAGE,wFAMA,kFAOF,sDDrxEA,+BAGA,uFAGA,2DAIA,wFAGA,sKASA,iECmpEA,iBAGA,iCAIA,8CAGA,uBAGA,wDAKA,kCAGA,iCAGA,0DAKA,mDAIA,4CAGA,yDAIA,sDAIA,8BAGA,oDAGA,qFAOA,yDAOA,2FAIA,2DAKA,gDAGA,yCAEE,2BAGA,8FAGA,yDAEF,qEAGA,0BAGA,sDAGE,wFAMA,kFAOF","sources":["index.47e6a91b.css","code/components/Card.vue","code/components/Main.vue"],"sourcesContent":[".card .n-card-header {\n  padding: 0;\n}\n\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content {\n  width: 100px;\n  flex: 1;\n}\n\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content .card-summary {\n  text-align: right;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex: 1;\n  font-size: 85%;\n  line-height: 1.5;\n  overflow: hidden;\n}\n\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n\nhtml {\n  height: 100%;\n}\n\nbody {\n  height: 100%;\n  overflow: hidden;\n}\n\n.n-tabs .n-tabs-pane-wrapper {\n  overflow: visible;\n}\n\n.n-layout {\n  height: 100vh;\n}\n\n.n-tabs {\n  max-width: 600px;\n  margin: 80px auto;\n  padding: 0 10px;\n}\n\n.n-tabs .n-tabs-tab-pad {\n  width: 5px;\n}\n\n.n-tabs .n-tabs-tab {\n  padding: 10px;\n}\n\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n\n.s-table td {\n  vertical-align: middle;\n  line-height: 19px;\n}\n\n.s-table td .n-switch {\n  vertical-align: middle;\n}\n\n.n-card {\n  box-shadow: var(--n-box-shadow);\n  border-radius: 5px;\n}\n\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n\n.n-rate {\n  vertical-align: middle;\n}\n\n.n-rate__item svg circle {\n  stroke: var(--n-text-color);\n}\n\n.n-rate__item--active svg circle {\n  fill: var(--n-text-color);\n  stroke: var(--n-text-color);\n}\n\n.quick {\n  z-index: 10;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n  z-index: 10;\n  position: fixed !important;\n}\n\n#spellAffix {\n  width: 100%;\n  max-width: 580px;\n  margin-bottom: -48px;\n}\n\n.btn-only-icon-when-small {\n  height: auto !important;\n}\n\n@media only screen and (max-width: 600px) {\n  #spellAffix {\n    max-width: 100%;\n  }\n\n  #spellAffix.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n    max-width: calc(100% - 20px);\n  }\n\n  .btn-only-icon-when-small .n-button__icon {\n    margin-right: 0;\n  }\n\n  .btn-only-icon-when-small .n-button__content {\n    display: none !important;\n  }\n}\n\n.spellSummary {\n  height: 45px;\n}\n\n.spellSummary .n-card__content {\n  padding: 10px !important;\n}\n\n.quick .n-card__content {\n  max-width: 600px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px !important;\n}\n\n#spellOptions {\n  width: auto;\n  border-radius: 70px;\n  position: fixed;\n  bottom: 10px;\n  right: 10px;\n}\n\n#spellOptions .n-card__content {\n  padding: 10px !important;\n}\n\n.card .n-card-header {\n  padding: 0;\n}\n\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content {\n  width: 100px;\n  flex: 1;\n}\n\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content .card-summary {\n  text-align: right;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex: 1;\n  font-size: 85%;\n  line-height: 1.5;\n  overflow: hidden;\n}\n\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n\nhtml {\n  height: 100%;\n}\n\nbody {\n  height: 100%;\n  overflow: hidden;\n}\n\n.n-tabs .n-tabs-pane-wrapper {\n  overflow: visible;\n}\n\n.n-layout {\n  height: 100vh;\n}\n\n.n-tabs {\n  max-width: 600px;\n  margin: 80px auto;\n  padding: 0 10px;\n}\n\n.n-tabs .n-tabs-tab-pad {\n  width: 5px;\n}\n\n.n-tabs .n-tabs-tab {\n  padding: 10px;\n}\n\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n\n.s-table td {\n  vertical-align: middle;\n  line-height: 19px;\n}\n\n.s-table td .n-switch {\n  vertical-align: middle;\n}\n\n.n-card {\n  box-shadow: var(--n-box-shadow);\n  border-radius: 5px;\n}\n\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n\n.n-rate {\n  vertical-align: middle;\n}\n\n.n-rate__item svg circle {\n  stroke: var(--n-text-color);\n}\n\n.n-rate__item--active svg circle {\n  fill: var(--n-text-color);\n  stroke: var(--n-text-color);\n}\n\n.quick {\n  z-index: 10;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n  z-index: 10;\n  position: fixed !important;\n}\n\n#spellAffix {\n  width: 100%;\n  max-width: 580px;\n  margin-bottom: -48px;\n}\n\n.btn-only-icon-when-small {\n  height: auto !important;\n}\n\n@media only screen and (max-width: 600px) {\n  #spellAffix {\n    max-width: 100%;\n  }\n\n  #spellAffix.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n    max-width: calc(100% - 20px);\n  }\n\n  .btn-only-icon-when-small .n-button__icon {\n    margin-right: 0;\n  }\n\n  .btn-only-icon-when-small .n-button__content {\n    display: none !important;\n  }\n}\n\n.spellSummary {\n  height: 45px;\n}\n\n.spellSummary .n-card__content {\n  padding: 10px !important;\n}\n\n.quick .n-card__content {\n  max-width: 600px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px !important;\n}\n\n#spellOptions {\n  width: auto;\n  border-radius: 70px;\n  position: fixed;\n  bottom: 10px;\n  right: 10px;\n}\n\n#spellOptions .n-card__content {\n  padding: 10px !important;\n}\n\n/*# sourceMappingURL=index.47e6a91b.css.map */\n","<template>\n  <n-card size=\"small\" class=\"card\">\n    <template #header v-if=\"title && title.length > 0\">\n      <n-button size=\"large\" text block @click=\"open = !open\">\n        <template #icon>\n          <n-icon>\n            <ChevronUp v-if=\"open == true\" />\n            <ChevronDown v-if=\"open === false\" />\n          </n-icon>\n        </template>\n        <n-text strong class=\"card-title\">{{ title }}</n-text>\n        <n-text depth=\"3\" class=\"card-summary\" editable>{{ summary }}</n-text>\n      </n-button>\n    </template>\n    <template #default v-if=\"open === true\">\n      <slot name=\"content\"></slot>\n    </template>\n    <template #action v-if=\"open === true\">\n      <slot name=\"footer\"></slot>\n    </template>\n  </n-card>\n</template>\n\n<script>\nimport { ChevronDown, ChevronUp } from \"@vicons/ionicons5\"\n\nexport default {\n  components: { ChevronDown, ChevronUp },\n  props: [\"title\", \"summary\", \"collapsed\"],\n  data() {\n    return {\n      open: true,\n    }\n  },\n  mounted() {\n    if (this.collapsed !== undefined) this.open = !!this.collapsed\n  },\n}\n</script>\n\n<style>\n.card .n-card-header {\n  padding: 0;\n}\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n.card .n-card-header .n-button__content {\n  flex: 1;\n  width: 100px;\n}\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n.card .n-card-header .n-button__content .card-summary {\n  flex: 1;\n  text-align: right;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 85%;\n  line-height: 1.5;\n}\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n</style>\n","<template>\n  <n-config-provider :theme=\"theme\" :theme-overrides=\"{ common: { fontWeightStrong: '600' } }\">\n    <n-layout static embedded>\n      <n-tabs default-value=\"spell\" animated>\n        <template #suffix>\n          <n-select ref=\"chooseCasterDropdown\" :value=\"chooseCasterValue\" filterable placeholder=\"Choose character to edit\" @update:value=\"chooseCaster\" :options=\"chooseCasterOptions\">\n            <template #action>\n              <n-button @click=\"createCaster\" type=\"success\" text>Create a new character</n-button>\n            </template>\n          </n-select>\n        </template>\n        <n-tab-pane name=\"caster\" tab=\"Caster\">\n          <n-space vertical>\n            <!-- Info -->\n            <n-alert type=\"warning\" v-if=\"caster === undefined || caster === null\">\n              <n-text>You don't have a character selected</n-text>\n            </n-alert>\n            <!-- Caster -->\n            <Card title=\"\" v-if=\"caster\">\n              <template #content>\n                <n-space vertical size=\"large\">\n                  <n-grid :cols=\"2\" :x-gap=\"10\" :y-gap=\"10\">\n                    <n-grid-item>\n                      <n-space vertical size=\"small\">\n                        <b>Name</b>\n                        <n-input v-model:value=\"caster.name\" type=\"text\" placeholder=\"eg. Merlin\" />\n                      </n-space>\n                    </n-grid-item>\n                    <n-grid-item>\n                      <n-space vertical size=\"small\">\n                        <b>Category</b>\n                        <n-input v-model:value=\"caster.type\" type=\"text\" placeholder=\"eg. Cabal\" />\n                      </n-space>\n                    </n-grid-item>\n                  </n-grid>\n                </n-space>\n              </template>\n              <template #footer>\n                <n-space justify=\"space-between\">\n                  <n-button strong text type=\"error\" @click=\"removeCaster(caster.id)\">\n                    <template #icon>\n                      <n-icon>\n                        <Trash />\n                      </n-icon>\n                    </template>\n                    Delete\n                  </n-button>\n                </n-space>\n              </template>\n            </Card>\n            <!-- Gnosis -->\n            <Card title=\"Gnosis\" :summary=\"gnosisSummary\" v-if=\"caster\">\n              <template #content>\n                <n-rate clearable :count=\"10\" v-model:value=\"caster.gnosis\">\n                  <n-icon>\n                    <EllipseOutline />\n                  </n-icon>\n                </n-rate>\n              </template>\n            </Card>\n            <!-- Praxes -->\n            <Card title=\"Praxes\" :summary=\"casterPraxesSummary\" v-if=\"caster\">\n              <template #content>\n                <n-space vertical>\n                  <n-table v-if=\"caster.praxes.length > 0\" striped class=\"s-table\">\n                    <tbody>\n                      <tr v-for=\"item in caster.praxes\" :key=\"item.name\">\n                        <td>{{ item.name }}</td>\n                        <td width=\"20\">\n                          <n-button size=\"tiny\" type=\"error\" @click=\"removePraxisSpell(item.name)\">\n                            <template #icon>\n                              <n-icon>\n                                <Close />\n                              </n-icon>\n                            </template>\n                          </n-button>\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                  <n-select ref=\"choosePraxisDropdown\" filterable :value=\"choosePraxisValue\" placeholder=\"Choose spell to add\" @update:value=\"(v) => choosePraxisFromDropdown(v)\" :options=\"chooseSpellOptions\" />\n                </n-space>\n              </template>\n            </Card>\n            <!-- Rotes -->\n            <Card title=\"Rotes\" :summary=\"casterRotesSummary\" v-if=\"caster\">\n              <template #content>\n                <n-space vertical class=\"s-table\">\n                  <n-table v-if=\"caster.rotes.length > 0\" striped class=\"s-table\">\n                    <tbody>\n                      <tr v-for=\"item in caster.rotes\" :key=\"item.name\">\n                        <td>{{ item.name}}</td>\n                        <td width=\"50\">\n                          <n-rate clearable :count=\"5\" v-model:value=\"item.skill\">\n                            <n-icon>\n                              <EllipseOutline />\n                            </n-icon>\n                          </n-rate>\n                        </td>\n                        <td width=\"20\">\n                          <n-button size=\"tiny\" type=\"error\" @click=\"removeRoteSpell(item.name)\">\n                            <template #icon>\n                              <n-icon>\n                                <Close />\n                              </n-icon>\n                            </template>\n                          </n-button>\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                  <n-select ref=\"chooseRoteDropdown\" filterable :value=\"chooseRoteValue\" placeholder=\"Choose spell to add\" @update:value=\"(v) => chooseRoteFromDropdown(v)\" :options=\"chooseSpellOptions\" />\n                </n-space>\n              </template>\n            </Card>\n            <!-- Arcana -->\n            <Card title=\"Arcana\" :summary=\"arcanaSummary\" v-if=\"caster\">\n              <template #content>\n                <n-table striped :bordered=\"false\" class=\"s-table\" style=\"margin-left: -8px; width: calc(100% + 16px)\">\n                  <tbody>\n                    <tr v-for=\"(item, name) of caster.arcana\" :key=\"name\">\n                      <td width=\"50\">\n                        <n-text>{{ name }}</n-text>\n                      </td>\n                      <td width=\"20\">\n                        <n-switch size=\"small\" v-model:value=\"item.ruling\" />\n                      </td>\n                      <td>\n                        <n-rate clearable :count=\"5\" v-model:value=\"item.level\">\n                          <n-icon>\n                            <EllipseOutline />\n                          </n-icon>\n                        </n-rate>\n                      </td>\n                    </tr>\n                  </tbody>\n                </n-table>\n              </template>\n            </Card>\n          </n-space>\n        </n-tab-pane>\n        <n-tab-pane name=\"spell\" tab=\"Spell\" :ref=\"container\">\n          <n-space vertical>\n            <!-- Info -->\n            <n-alert type=\"warning\" v-if=\"hasConfiguredCaster === false\">\n              <n-text v-if=\"caster === undefined || caster === null\">You don't have a character selected</n-text>\n              <n-text v-else>You haven't set Gnosis and Arcana for this character</n-text>\n            </n-alert>\n            <n-affix id=\"spellAffix\" v-if=\"hasConfiguredCaster === true\" :trigger-top=\"10\" position=\"absolute\" listen-to=\".n-layout-scroll-container\">\n              <n-card class=\"spellSummary\">\n                <n-space align=\"center\" justify=\"space-between\">\n                  <n-space size=\"small\" v-if=\"canCastSpell\">\n                    <n-tag size=\"small\" :bordered=\"false\" round strong :type=\"usedReach > freeReach ? 'warning' : 'success'\"> {{ usedReach }}/{{ freeReach }} Reach</n-tag>\n                    <n-tag size=\"small\" :bordered=\"false\" round strong :type=\"isDicePoolTooLow ? 'warning' : 'success'\"> {{ dicePool }} Dice</n-tag>\n                    <n-tag size=\"small\" :bordered=\"false\" round strong type=\"success\">{{ totalMana }} Mana</n-tag>\n                    <n-tag v-if=\"hasParadox\" size=\"small\" :bordered=\"false\" round strong type=\"error\">{{ paradoxDice }} Paradox</n-tag>\n                  </n-space>\n                  <n-space size=\"small\" v-if=\"canCastSpell === false\">\n                    <n-tag size=\"small\" disabled :bordered=\"false\" round strong>0/0 Reach</n-tag>\n                    <n-tag size=\"small\" disabled :bordered=\"false\" round strong>0 Dice</n-tag>\n                    <n-tag size=\"small\" disabled :bordered=\"false\" round strong>0 Mana</n-tag>\n                  </n-space>\n                  <n-space size=\"small\">\n                    <n-button class=\"btn-only-icon-when-small\" title=\"Reset\" :disabled=\"canCastSpell === false\" size=\"tiny\" type=\"warning\" @click=\"reset\">\n                      <template #icon>\n                        <n-icon>\n                          <ArrowUndo />\n                        </n-icon>\n                      </template>\n                      Reset\n                    </n-button>\n                    <n-button class=\"btn-only-icon-when-small\" title=\"Copy for Roll20\" :disabled=\"canCastSpell === false\" size=\"tiny\" type=\"info\" @click=\"copyActiveSpell()\">\n                      <template #icon>\n                        <n-icon>\n                          <DocumentText />\n                        </n-icon>\n                      </template>\n                      Roll20\n                    </n-button>\n                    <n-button class=\"btn-only-icon-when-small\" title=\"Save\" :disabled=\"canCastSpell === false\" size=\"tiny\" type=\"success\" @click=\"saveActiveSpell()\">\n                      <template #icon>\n                        <n-icon>\n                          <Bookmark />\n                        </n-icon>\n                      </template>\n                      Save\n                    </n-button>\n                  </n-space>\n                </n-space>\n              </n-card>\n            </n-affix>\n            <!-- Spell -->\n            <Card title=\"Spell\" :summary=\"spellSummary\" v-if=\"hasConfiguredCaster\" style=\"margin-top: 48px\">\n              <template #content>\n                <n-space vertical size=\"large\">\n                  <n-select filterable placeholder=\"What spell are you casting?\" :value=\"chooseSpellLabel\" @update:value=\"chooseSpell\" :options=\"chooseSpellOptions\" />\n                  <n-alert type=\"warning\" v-if=\"(spell.name || spell.custom) && isSpellArcanaTooHigh\">\n                    <n-text>You don't have the arcana required for this spell</n-text>\n                  </n-alert>\n                  <n-alert type=\"info\" v-if=\"hasPraxis(spell.name)\">\n                    <n-text>{{ spell.name }} is one of your Praxes.</n-text>\n                  </n-alert>\n                  <n-alert type=\"info\" v-if=\"hasRote(spell.name)\">\n                    <n-text>{{ spell.name }} is one of your Rotes (+{{ hasRote(spell.name).skill }} bonus).</n-text>\n                  </n-alert>\n                </n-space>\n              </template>\n              <template #footer v-if=\"spell.name\">\n                <n-space vertical size=\"large\">\n                  <n-text depth=\"3\" v-if=\"spell.description\">\n                    {{ spell.description }} <span v-if=\"spell.page\"><br />({{ spell.page }})</span>\n                  </n-text>\n                  <n-grid :cols=\"4\">\n                    <n-grid-item>\n                      <n-text> <b>Practice</b><br />{{ spell.practice }} </n-text>\n                    </n-grid-item>\n                    <n-grid-item>\n                      <n-text> <b>Factor</b><br />{{ spell.primaryFactor }} </n-text>\n                    </n-grid-item>\n                    <n-grid-item :span=\"2\" v-if=\"spell.roteSkills.length > 0\">\n                      <n-text> <b>Rote Skills</b><br />{{  spell.roteSkills.join(\", \") }}</n-text>\n                    </n-grid-item>\n                  </n-grid>\n                </n-space>\n              </template>\n              <template #footer v-if=\"!spell.name && spell.custom\">\n                <n-space vertical size=\"large\">\n                  <n-grid :cols=\"2\" :x-gap=\"10\" :y-gap=\"10\">\n                    <n-grid-item>\n                      <n-space vertical size=\"small\">\n                        <b>Name</b>\n                        <n-input v-model:value=\"spell.customName\" type=\"text\" placeholder=\"What is the spell named?\" />\n                      </n-space>\n                    </n-grid-item>\n                    <n-grid-item>\n                      <n-space vertical size=\"small\">\n                        <b>Arcana</b>\n                        <n-select placeholder=\"Choose an arcanum\" filterable v-model:value=\"spell.primaryArcana.arcana\" :options=\"arcanaOptions\" />\n                      </n-space>\n                    </n-grid-item>\n                    <n-grid-item>\n                      <n-space vertical size=\"small\">\n                        <b>Practice</b>\n                        <n-select placeholder=\"Choose a practice\" filterable :value=\"choosePracticeValue\" :options=\"choosePracticeOptions\" @update:value=\"choosePractice\" />\n                      </n-space>\n                    </n-grid-item>\n                    <n-grid-item>\n                      <n-space vertical size=\"small\">\n                        <b>Factor</b>\n                        <n-select placeholder=\"Choose a primary factor\" filterable v-model:value=\"spell.primaryFactor\" :options=\"choosePrimaryFactorOptions\" />\n                      </n-space>\n                    </n-grid-item>\n                  </n-grid>\n                  <n-input v-model:value=\"spell.description\" type=\"textarea\" placeholder=\"What does this spell do? Describe the effects and conditions that would apply. Entering this description is mostly useful if you are going to save the spell.\" />\n                  <n-space justify=\"end\">\n                    <n-button :disabled=\"spell.primaryArcana.arcana == undefined || spell.practice === undefined || spell.customName === undefined || spell.customName === ''\" type=\"success\" @click=\"applyCustomSpell\">Create this spell</n-button>\n                  </n-space>\n                </n-space>\n              </template>\n            </Card>\n            <!-- Effects -->\n            <Card title=\"Effects\" collapsed :summary=\"effectsSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-space vertical>\n                  <n-table bordered striped class=\"s-table\" style=\"margin-left: -5px; width: calc(100% + 10px)\">\n                    <tbody>\n                      <tr v-if=\"spell.custom === true\">\n                        <td>\n                          <n-switch size=\"small\" :disabled=\"true\" :value=\"spell.extraMana > 0\" />\n                        </td>\n                        <td colspan=\"2\">\n                          <n-space vertical>\n                            <b>+{{ spell.extraMana }} Mana for spell effects</b>\n                            <n-slider :tooltip=\"false\" v-model:value=\"spell.extraMana\" :min=\"0\" :max=\"10\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                      <tr v-if=\"spell.custom === true\">\n                        <td>\n                          <n-switch size=\"small\" :disabled=\"true\" :value=\"spell.extraReach > 0\" />\n                        </td>\n                        <td colspan=\"2\">\n                          <n-space vertical>\n                            <b>+{{ spell.extraReach }} Reach for spell effects</b>\n                            <n-slider :tooltip=\"false\" v-model:value=\"spell.extraReach\" :min=\"0\" :max=\"10\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" v-model:value=\"spell.spendWillpower\" />\n                        </td>\n                        <td width=\"150\" colspan=\"2\"><b>+1 Willpower:</b><br />Gain +3 spellcasting dice.</td>\n                      </tr>\n                      <tr>\n                        <td width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" v-model:value=\"spell.commonEffects.changePrimaryFactor\" />\n                        </td>\n                        <td colspan=\"2\"><b>+1 Reach:</b><br />Change the primary factor.</td>\n                      </tr>\n                      <tr v-if=\"spell.custom !== true\" v-for=\"(item, index) of spell.additionalEffects\" :key=\"index\">\n                        <td v-if=\"item.cost\" width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" :disabled=\"isEffectRestricted(item)\" :value=\"isEffectAdded(item)\" @update:value=\"toggleEffect(item)\" />\n                        </td>\n                        <td v-if=\"item.cost\" colspan=\"2\">\n                          <b>{{ item.cost.map(c => `+${c.value} ${c.type}`).join(\", \")}}</b\n                          ><b v-if=\"item.requirement\"> ({{ item.requirement.map(v => `${v.arcana} ${v.value}`).join(\", \") }})</b><b>:</b><br />\n                          {{ item.effect }}\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                </n-space>\n              </template>\n            </Card>\n            <!-- Potency -->\n            <Card title=\"Potency\" collapsed :summary=\"potencySummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.potency\" :options=\"potencyOptions\" />\n              </template>\n              <template #footer> Advanced Potency grants an additional -2 to Withstand. </template>\n            </Card>\n            <!-- Duration -->\n            <Card title=\"Duration\" collapsed :summary=\"durationSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.duration\" :options=\"durationOptions\" />\n              </template>\n              <template #footer v-if=\"spell.factors.duration === 'a6'\"> Indefinite duration requires +1 Reach and +1 Mana above the normal amount.</template>\n            </Card>\n            <!-- Casting Time -->\n            <Card title=\"Casting Time\" collapsed :summary=\"castingTimeSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.castingTime\" :options=\"castingTimeOptions\" />\n              </template>\n              <template #footer v-if=\"isAdvanced('castingTime')\"> Using more than one Yantra (or High Speech) will increase this time. </template>\n            </Card>\n            <!-- Range -->\n            <Card title=\"Range\" collapsed :summary=\"rangeSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.range\" :options=\"rangeOptions\" />\n              </template>\n              <template #footer v-if=\"spell.factors.range === 'a2'\"> Remote Viewing range requires +1 Reach above the normal amount.</template>\n            </Card>\n            <!-- Scale -->\n            <Card title=\"Scale\" collapsed :summary=\"scaleSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.scale\" :options=\"scaleOptions\" />\n              </template>\n              <template #footer> Advanced Scale doubles the number of subjects and adds 5 size per additional -2 dice penalty. </template>\n            </Card>\n            <!-- Yantras -->\n            <Card title=\"Yantras\" collapsed :summary=\"yantrasSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-space vertical>\n                  <n-table striped v-if=\"spell.yantras.length > 0\">\n                    <tbody>\n                      <tr v-for=\"yantra, index in spell.yantras\" :key=\"index\">\n                        <td>\n                          <n-space vertical size=\"small\">\n                            <n-text strong>{{ yantra.label }}</n-text>\n                            <n-text>{{ yantra.desc }}</n-text>\n                            <n-space size=\"small\" v-if=\"yantra.yantraKey === 't2' || yantra.yantraKey === 't3'\">\n                              <n-switch size=\"small\" v-model:value=\"yantra.isDedicatedTool\" @update:value=\"(v) => updateYantraIsDedicatedTool(yantra.yantraKey, v)\" />\n                              <n-text>This is your Dedicated Tool</n-text>\n                            </n-space>\n                          </n-space>\n                        </td>\n                        <td width=\"20\" valign=\"top\" style=\"vertical-align: top\">\n                          <n-button size=\"small\" type=\"error\" @click=\"deleteYantra(yantra.yantraKey)\">\n                            <template #icon>\n                              <n-icon>\n                                <Close />\n                              </n-icon>\n                            </template>\n                          </n-button>\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                  <n-select ref=\"chooseYantraDropdown\" :options=\"yantraOptions\" :value=\"chooseYantraValue\" :render-label=\"renderYantraLabel\" filterable @update:value=\"chooseYantraFromDropdown\" />\n                </n-space>\n              </template>\n              <template #footer> Gnosis {{ caster.gnosis }} allows the use of {{ maxYantras }} yantras. </template>\n            </Card>\n            <!-- Paradox -->\n            <Card title=\"Paradox\" collapsed :summary=\"paradoxSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-space vertical>\n                  <n-table bordered striped class=\"s-table\" style=\"margin-left: -5px; width: calc(100% + 10px)\">\n                    <tbody>\n                      <tr>\n                        <td width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" v-model:value=\"paradox.inured\" />\n                        </td>\n                        <td colspan=\"2\">\n                          <b>Mage is inured?</b>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td colspan=\"3\">\n                          <n-space vertical>\n                            <b>Previous paradox rolls? ({{paradox.previous}})</b>\n                            <n-slider placement=\"bottom\" v-model:value=\"paradox.previous\" :min=\"0\" :max=\"10\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td colspan=\"3\">\n                          <n-space vertical>\n                            <b>Sleeper witnesses? ({{ ['None', 'One', 'Some', 'Many', 'Crowd'][paradox.sleepers] }})</b>\n                            <n-slider placement=\"bottom\" v-model:value=\"paradox.sleepers\" :min=\"0\" :max=\"4\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td colspan=\"3\">\n                          <n-space vertical>\n                            <b>Mana spent? ({{ paradox.manaSpent }})</b>\n                            <n-slider placement=\"bottom\" v-model:value=\"paradox.manaSpent\" :min=\"0\" :max=\"caster.gnosis\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                </n-space>\n              </template>\n              <template #footer> Multiple witnesses do not add Paradox dice, but increase the chances of a Paradox occurring. Mana can be spent to mitigate Paradox, but is limited by Gnosis. </template>\n            </Card>\n            <!-- Conditions -->\n            <Card title=\"Conditions\" collapsed :summary=\"conditionsSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-table bordered striped class=\"s-table\" style=\"margin-left: -5px; width: calc(100% + 10px)\">\n                  <tbody>\n                    <tr>\n                      <td colspan=\"3\">\n                        <n-space vertical>\n                          <b>Bonus spellcasting dice (+{{conditions.bonusDice}} dice)</b>\n                          <n-slider placement=\"bottom\" v-model:value=\"conditions.bonusDice\" :min=\"0\" :max=\"10\" />\n                        </n-space>\n                      </td>\n                    </tr>\n                    <tr>\n                      <td colspan=\"3\">\n                        <n-space vertical>\n                          <b>Number of active spells ({{conditions.activeSpells}})</b>\n                          <n-slider placement=\"bottom\" v-model:value=\"conditions.activeSpells\" :min=\"0\" :max=\"10\" />\n                        </n-space>\n                      </td>\n                    </tr>\n                    <tr>\n                      <td colspan=\"3\">\n                        <n-space vertical>\n                          <b>Withstand rating of subject (+{{conditions.subjectWithstand}})</b>\n                          <n-slider placement=\"bottom\" v-model:value=\"conditions.subjectWithstand\" :min=\"0\" :max=\"10\" />\n                        </n-space>\n                      </td>\n                    </tr>\n                  </tbody>\n                </n-table>\n              </template>\n              <template #footer v-if=\"conditionsSummary !== 'None'\">\n                <n-space vertical>\n                  <n-text v-if=\"conditions.bonusDice > 0\"><b>Bonus:</b> Can come from Fate magic, Merits, Artefacts, or the Storyteller.</n-text>\n                  <n-text v-if=\"conditions.activeSpells > 0\"><b>Spells:</b> Maintaining more spells than the caster's Gnosis adds +1 Reach for each spell over the limit.</n-text>\n                  <n-text v-if=\"conditions.subjectWithstand > 0\"><b>Withstand:</b> Potency must exceed this rating for the spell to take effect.</n-text>\n                </n-space>\n              </template>\n            </Card>\n          </n-space>\n        </n-tab-pane>\n        <n-tab-pane name=\"saved\" :tab=\"`Saved (${saved.length})`\">\n          <n-space vertical>\n            <!-- Info -->\n            <n-alert type=\"warning\" v-if=\"hasConfiguredCaster === false\">\n              <n-text v-if=\"caster === undefined || caster === null\">You don't have a character selected</n-text>\n              <n-text v-if=\"caster !== undefined && caster !== null\">You haven't set Gnosis and Arcana for this character</n-text>\n            </n-alert>\n            <n-alert type=\"info\" v-if=\"saved.length === 0\">\n              <n-text>You don't have any saved spells</n-text>\n            </n-alert>\n            <!-- Saved -->\n            <Card v-if=\"hasConfiguredCaster\" :title=\"item.name\" collapsed :summary=\"item.summary\" v-for=\"(item) in saved\" :key=\"item.id\">\n              <template #content>\n                <n-space vertical size=\"large\">\n                  <n-space size=\"small\" v-if=\"item.tags\">\n                    <n-tag v-if=\"item.tags.method\" size=\"small\" :bordered=\"false\" round strong style=\"text-transform: capitalize\">{{ item.tags.method }}</n-tag>\n                    <n-tag size=\"small\" :bordered=\"false\" round strong type=\"success\">{{ item.tags.reach }} Reach</n-tag>\n                    <n-tag size=\"small\" :bordered=\"false\" round strong type=\"success\"> {{ item.tags.dice }} Dice</n-tag>\n                    <n-tag size=\"small\" :bordered=\"false\" round strong type=\"success\">{{ item.tags.mana }} Mana</n-tag>\n                    <n-tag v-if=\"item.tags.paradox\" size=\"small\" :bordered=\"false\" round strong type=\"error\">{{ item.tags.paradox }} Paradox</n-tag>\n                  </n-space>\n                  <n-text><b>Factors:</b> {{ item.factorSummary }}.</n-text>\n                  <n-text v-if=\"item.effectSummary\"><b>Extra:</b> {{ item.effectSummary }}</n-text>\n                  <n-text v-if=\"item.yantraSummary\"><b>Yantras:</b> {{ item.yantraSummary }}.</n-text>\n                </n-space>\n              </template>\n              <template #footer>\n                <n-space justify=\"space-between\">\n                  <n-button class=\"btn-only-icon-when-small\" title=\"Remove\" size=\"tiny\" type=\"error\" @click=\"removeSpell(item)\">\n                    <template #icon>\n                      <n-icon>\n                        <Trash />\n                      </n-icon>\n                    </template>\n                    Remove\n                  </n-button>\n                  <n-space>\n                    <n-button class=\"btn-only-icon-when-small\" title=\"Copy for Roll20\" size=\"tiny\" type=\"info\" @click=\"copySavedSpell(item)\">\n                      <template #icon>\n                        <n-icon>\n                          <DocumentText />\n                        </n-icon>\n                      </template>\n                      Roll20\n                    </n-button>\n                    <n-button class=\"btn-only-icon-when-small\" title=\"Edit\" size=\"tiny\" type=\"success\" @click=\"loadSpell(item)\">\n                      <template #icon>\n                        <n-icon>\n                          <Build />\n                        </n-icon>\n                      </template>\n                      Edit\n                    </n-button>\n                  </n-space>\n                </n-space>\n              </template>\n            </Card>\n          </n-space>\n        </n-tab-pane>\n      </n-tabs>\n    </n-layout>\n  </n-config-provider>\n</template>\n\n<script>\nimport { ref, h } from \"vue\"\nimport { clone, max, some, capitalize, findIndex, range } from \"lodash\"\nimport { useMessage } from \"naive-ui\"\nimport { darkTheme, lightTheme } from \"naive-ui\"\n\nimport { Close, DocumentText, Save, Trash, Build, Bookmark, ArrowUndo, Reload, ChevronDown, ChevronUp, Ellipse, EllipseOutline } from \"@vicons/ionicons5\"\n\nimport Card from \"./Card.vue\"\n\nimport {\n  arcanaNames,\n  baseCastingTimes,\n  castingMethods,\n  factors,\n  gnosisManaLimits,\n  durations,\n  scales,\n  practices,\n  yantrasBaseData,\n} from \"../constants/constants.js\"\nimport { spells } from \"../constants/spells.js\"\n\nfunction dots(num) {\n  return Array.from({ length: num }, () => \"•\").join(\"\")\n}\n\nconst defaultCaster = {\n  id: 0,\n  name: \"Character\",\n  type: \"Uncategorised\",\n  gnosis: 0,\n  arcana: {\n    Death: { level: 0, ruling: false },\n    Fate: { level: 0, ruling: false },\n    Forces: { level: 0, ruling: false },\n    Life: { level: 0, ruling: false },\n    Matter: { level: 0, ruling: false },\n    Mind: { level: 0, ruling: false },\n    Prime: { level: 0, ruling: false },\n    Spirit: { level: 0, ruling: false },\n    Space: { level: 0, ruling: false },\n    Time: { level: 0, ruling: false },\n  },\n  praxes: [],\n  rotes: [],\n}\nconst defaultSpell = {\n  name: undefined,\n  isRote: false,\n  isPraxis: false,\n  practice: undefined,\n  primaryFactor: undefined,\n  primaryArcana: { arcana: undefined, level: undefined },\n  secondaryArcana: { arcana: undefined, level: undefined },\n  description: undefined,\n  effects: [],\n  additionalEffects: [],\n  commonEffects: {\n    changePrimaryFactor: false,\n  },\n  description: undefined,\n  page: undefined,\n  factors: {\n    castingTime: \"s1\",\n    potency: \"s1\",\n    range: \"s1\",\n    duration: \"s1\",\n    scale: \"s1\",\n  },\n  roteSkills: [],\n  roteSkill: 0,\n  spendWillpower: false,\n  extraReach: 0,\n  extraMana: 0,\n  yantras: [],\n  yantraAlsoDedicatedTool: null,\n  attainments: {\n    conditionalDuration: false,\n    everywhere: false,\n    permanence: false,\n    sympatheticRange: false,\n    temporalSympathy: false,\n    timeInABottle: false,\n  },\n}\nconst defaultConditions = {\n  subjectWithstand: 0,\n  activeSpells: 0,\n  bonusDice: 0,\n}\nconst defaultParadox = {\n  inured: false,\n  previous: 0,\n  sleepers: 0,\n  manaSpent: 0,\n}\n\nexport default {\n  components: { Card, DocumentText, Trash, Build, Bookmark, ArrowUndo, Save, Reload, Close, ChevronDown, ChevronUp, Ellipse, EllipseOutline },\n  setup() {\n    const message = useMessage()\n    const container = ref(undefined)\n    const createCasterButton = ref(undefined)\n    const chooseCasterDropdown = ref(undefined)\n    const chooseYantraDropdown = ref(undefined)\n    const choosePraxisDropdown = ref(undefined)\n    const chooseRoteDropdown = ref(undefined)\n    return {\n      darkTheme,\n      lightTheme,\n      container: container,\n      message: message,\n      chooseCasterDropdown,\n      chooseYantraDropdown,\n      choosePraxisDropdown,\n      chooseRoteDropdown,\n      // theme: lightTheme,\n    }\n  },\n  data() {\n    return {\n      caster: null,\n      casters: [],\n      spell: clone(defaultSpell),\n      conditions: clone(defaultConditions),\n      paradox: clone(defaultParadox),\n      saved: [],\n      theme: lightTheme,\n      dark: false,\n      // chooseCasterValue: null,\n      chooseYantraValue: null,\n      choosePraxisValue: null,\n      chooseRoteValue: null,\n    }\n  },\n  computed: {\n    hasConfiguredCaster() {\n      if (!this.caster) return false\n      return this.caster.gnosis > 0 && this.highestCasterArcana.length > 0\n    },\n    canCastSpell() {\n      if (this.spell.name === undefined) return false\n      if (this.isSpellArcanaTooHigh === true) return false\n      return true\n    },\n    chooseCasterValue() {\n      if (!this.caster) return null\n      return this.caster.name\n    },\n    chooseCasterOptions() {\n      let options = []\n      let types = []\n\n      for (let caster of this.casters) {\n        if (types.includes(caster.type) === false) types.push(caster.type)\n      }\n\n      for (let type of types) {\n        options.push({\n          type: \"group\",\n          label: type,\n          key: type,\n          children: this.casters\n            .filter((c) => c.type === type)\n            .map((c) => {\n              return {\n                label: c.name,\n                value: c,\n              }\n            }),\n        })\n      }\n\n      return options\n    },\n    chooseSpellLabel() {\n      if (this.spell.name === undefined && this.spell.custom) return \"Creative Thaumaturgy\"\n      if (this.spell.name !== undefined && this.spell.custom) return `${this.spell.name} (Custom)`\n      return this.spell.name\n    },\n    chooseSpellOptions() {\n      let options = []\n\n      options.push({\n        type: \"group\",\n        label: \"Custom\",\n        key: \"custom\",\n        children: [{\n          label: \"Creative Thaumaturgy\",\n          value: {\n            name: \"Creative Thaumaturgy\",\n          }\n        }]\n      })\n\n      for (let arcanaName of arcanaNames) {\n        options.push({\n          type: \"group\",\n          label: arcanaName,\n          key: arcanaName,\n          children: spells\n            .filter((s) => s.primaryArcana.arcana === arcanaName)\n            .sort((a, b) => a.primaryArcana.level - b.primaryArcana.level)\n            .map((s) => {\n              return {\n                label: `${dots(s.primaryArcana.level)} ${s.name}`,\n                value: s,\n              }\n            }),\n        })\n      }\n\n      return options\n    },\n    methodOptions() {\n      let options = []\n\n      for (let method of castingMethods) {\n        options.push({\n          label: method,\n          value: method,\n        })\n      }\n\n      return options\n    },\n    arcanaNameOptions() {\n      let options = []\n\n      for (let arcanaName of arcanaNames) {\n        options.push({\n          label: arcanaName,\n          value: arcanaName,\n        })\n      }\n\n      return options\n    },\n    highestCasterArcana() {\n      let highest = max(Object.values(this.caster.arcana).map((a) => a.level))\n      let arcanas = []\n      if (highest === 0) return arcanas\n      for (let arcana in this.caster.arcana) {\n        if (this.caster.arcana[arcana].level === highest) arcanas.push(arcana)\n      }\n      return arcanas\n    },\n    maxCasterArcana() {\n      let arcana\n\n      if (this.highestCasterArcana.includes(this.spell.primaryArcana.arcana)) {\n        if (this.caster.gnosis >= 5) {\n          arcana = 5\n        } else if (this.caster.gnosis >= 3) {\n          arcana = 4\n        } else {\n          arcana = 3\n        }\n      } else {\n        if (this.caster.gnosis >= 6) {\n          arcana = 5\n        } else if (this.caster.gnosis >= 4) {\n          arcana = 4\n        } else {\n          arcana = 3\n        }\n      }\n\n      return arcana\n    },\n    isCasterArcanaTooHigh() {\n      return this.caster.arcana[this.spell.primaryArcana.arcana].level > this.maxCasterArcana\n    },\n    isSpellArcanaTooHigh() {\n      if (this.spell.primaryArcana && this.spell.primaryArcana.arcana && this.spell.primaryArcana.level && this.caster.arcana[this.spell.primaryArcana.arcana].level < this.spell.primaryArcana.level) return true\n      if (this.spell.secondaryArcana && this.spell.secondaryArcana.arcana && this.spell.secondaryArcana.level && this.caster.arcana[this.spell.secondaryArcana.arcana].level < this.spell.secondaryArcana.level) return true\n      return false\n    },\n    freeReach() {\n      let arcana\n\n      if (this.spell.isRote) {\n        arcana = 5\n      } else {\n        arcana = this.caster.arcana[this.spell.primaryArcana.arcana].level\n      }\n\n      return arcana - this.spell.primaryArcana.level + 1\n    },\n    usedReach() {\n      let reach = 0\n\n      if (this.conditions.activeSpells >= this.caster.gnosis) {\n        reach += this.conditions.activeSpells - this.caster.gnosis + 1\n      }\n\n      // check factors (advanced factor keys begin with \"a\")\n      for (let factor of factors) {\n        if (this.spell.factors[factor][0] === \"a\") {\n          reach++\n        }\n      }\n\n      // check effects\n      for (let effect of this.spell.effects) {\n        if (effect.cost) {\n          for (let cost of effect.cost) {\n            if (cost.type === \"Reach\") reach += cost.value\n          }\n        }\n      }\n\n      // check for common effects\n      if (this.spell.commonEffects.changePrimaryFactor) {\n        reach += 1\n      }\n\n      // remote viewing range costs 1 additional reach\n      if (this.spell.factors.range === \"a2\") {\n        reach += 1\n      }\n\n      // indefinite duration costs 1 additional reach\n      if (this.spell.factors.duration === \"a6\") {\n        reach += 1\n      }\n\n      // spell-specific extra reach\n      reach += this.spell.extraReach\n\n      if (this.spell.attainments.permanence) {\n        reach--\n      }\n\n      if (this.spell.attainments.timeInABottle) {\n        reach--\n      }\n\n      if (this.spell.attainments.everywhere) {\n        reach--\n      }\n\n      return reach\n    },\n    roteOrPraxis() {\n      if (this.spell.isRote) {\n        return \"rote\"\n      } else if (this.spell.isPraxis) {\n        return \"praxis\"\n      } else {\n        return null\n      }\n    },\n    baseParadoxDice() {\n      return Math.ceil(this.caster.gnosis / 2)\n    },\n    paradoxDice() {\n      let pool, mustRoll\n\n      pool = 0\n      mustRoll = false\n\n      if (this.usedReach > this.freeReach) {\n        pool += (this.freeReach - this.usedReach) * -1\n        mustRoll = true\n      }\n\n      // gnosis multiplies paradox from additional reach\n      pool *= this.baseParadoxDice\n\n      if (this.paradox.inured) {\n        pool += 2\n        mustRoll = true\n      }\n\n      if (this.paradox.previous > 0) {\n        pool += this.paradox.previous\n        mustRoll = true\n      }\n\n      if (this.paradox.sleepers > 0) {\n        pool++\n        mustRoll = true\n      }\n\n      if (this.isDedicatedToolYantraUsed) {\n        pool -= 2\n      }\n\n      pool -= this.paradox.manaSpent\n\n      if (pool <= 0 && mustRoll) {\n        return \"Chance\"\n      }\n      if (pool < 0) return 0\n\n      return pool\n    },\n    hasParadox() {\n      return (\n        this.usedReach > this.freeReach ||\n        this.paradox.inured ||\n        this.paradox.previous > 0 ||\n        this.paradox.sleepers > 0\n      )\n    },\n    durationPenalty() {\n      let penalty = durations.get(this.spell.factors.duration).penalty\n\n      if (this.isPrimaryFactor(\"Duration\")) {\n        penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n      }\n\n      if (penalty <= 0) {\n        penalty = 0\n      }\n\n      return penalty\n    },\n    potencyValue() {\n      return this.spell.factors.potency.substr(1)\n    },\n    potencyPenalty() {\n      let penalty = (this.potencyValue - 1) * 2\n\n      if (this.isPrimaryFactor(\"Potency\")) {\n        penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n      }\n\n      if (penalty <= 0) {\n        penalty = 0\n      }\n\n      return penalty\n    },\n    dicePool() {\n      // base pool\n      let pool = this.caster.gnosis + this.caster.arcana[this.spell.primaryArcana.arcana].level\n\n      pool += this.conditions.bonusDice\n\n      if (this.spell.spendWillpower) {\n        pool += 3\n      }\n\n      // casting time\n      if (!this.isAdvanced(\"castingTime\")) {\n        pool += this.spell.factors.castingTime[1] - 1\n      }\n\n      // withstand\n      pool -= this.totalWithstand\n\n      // potency\n      pool -= this.potencyPenalty\n\n      // duration\n      pool -= this.durationPenalty\n\n      // scale\n      pool -= scales.get(this.spell.factors.scale).penalty\n\n      // yantras\n      this.spell.yantras.forEach((yantra) => {\n        pool += yantra.bonus\n      })\n\n      return pool\n    },\n    isDicePoolTooLow() {\n      return this.dicePool < 1\n    },\n    spellFactorOptions() {\n      return [\n        {\n          label: \"Duration\",\n          value: \"Duration\",\n        },\n        {\n          label: \"Potency\",\n          value: \"Potency\",\n        },\n      ]\n    },\n    primaryFactor() {\n      return this.spell.primaryFactor\n    },\n    primaryFactorLabel() {\n      return capitalize(this.spell.primaryFactor)\n    },\n    totalWithstand() {\n\n      let withstand = this.conditions.subjectWithstand\n\n      if (this.spell.factors.potency === \"a1\") {\n        withstand -= 2\n      }\n\n      return withstand\n    },\n    yantras() {\n      let expandedYantras = new Map()\n\n      for (let [key, yantraBaseData] of yantrasBaseData) {\n        // bonus can contain a single number or a range. Arrayify.\n        let bonuses\n        if (Array.isArray(yantraBaseData.bonus)) {\n          bonuses = range(yantraBaseData.bonus[0], yantraBaseData.bonus[1] + 1)\n        } else {\n          bonuses = [yantraBaseData.bonus]\n        }\n\n        bonuses.forEach((bonus) => {\n          let expandedYantra = clone(yantraBaseData)\n\n          /*\n           * Bonus\n           */\n\n          // rote skill mudra: bonus = skill dots\n          if (key === \"a1\" && this.spell.isRote) {\n            bonus = this.spell.roteSkill\n          }\n\n          // sympathetic yantras don't give a bonus to sympathetic or temporal spells\n          if (\n            [\"t4\", \"t5\"].includes(key) &&\n            (this.spell.attainments.sympatheticRange || this.spell.attainments.temporalSympathy)\n          ) {\n            bonus = 0\n          }\n\n          expandedYantra.yantraKey = Array.isArray(yantraBaseData.bonus) ? key + \"_\" + bonus : key // key is a reserved property in Vue so we use \"yantraKey\"\n          expandedYantra.bonus = bonus\n          expandedYantra.value = expandedYantra.yantraKey\n          expandedYantra.label = `${yantraBaseData.name} (+${bonus} ${\n            bonus === 1 ? \"die\" : \"dice\"\n          })`\n          expandedYantra.isDedicatedTool = false\n          expandedYantras.set(expandedYantra.yantraKey, expandedYantra)\n        })\n      }\n\n      return expandedYantras\n    },\n    maxYantras() {\n      return Math.ceil(this.caster.gnosis / 2) + 1\n    },\n    numYantras() {\n      return this.spell.yantras.length\n    },\n    isConcentrationMantraAllowed() {\n      return this.isPrimaryFactor(\"Duration\") || this.spell.factors.duration !== \"s1\"\n    },\n    isDedicatedToolYantraUsed: {\n      cache: false,\n      // getter\n      get() {\n        if (this.hasYantra(\"t1\")) {\n          return true\n        }\n\n        return some(this.spell.yantras, [\"isDedicatedTool\", true])\n      },\n      // setter (bool)\n      set(isUsed) {\n        if (isUsed) {\n          console.log('set is used')\n          if (this.isDedicatedToolYantraUsed) {\n            console.log('but warn')\n            this.message.warning(\"Dedicated Tool is already being used\")\n          }\n          this.spell.yantras.push(this.yantras.get(\"t1\"))\n        } else {\n          console.log('delete t1?')\n          this.deleteYantra(\"t1\")\n\n          for (let key of this.spell.yantras) {\n            this.spell.yantras[key].isDedicatedTool = false\n          }\n\n          this.$forceUpdate() // cache: false and this.$forceUpdate() means the getter shows updated value\n        }\n      },\n    },\n    totalMana() {\n      let mana = 0\n\n      if (\n        !this.caster.arcana[this.spell.primaryArcana.arcana].ruling &&\n        !this.spell.isRote &&\n        !this.spell.isPraxis\n      ) {\n        mana++\n      }\n\n      // check effects\n      for (let effect of this.spell.effects) {\n        if (effect.cost) {\n          for (let cost of effect.cost) {\n            if (cost.type === \"Mana\") mana += cost.value\n          }\n        }\n      }\n\n      if (this.spell.extraMana) mana += this.spell.extraMana\n\n      if (this.spell.factors.duration === \"a6\") {\n        mana++\n      }\n\n      if (this.spell.attainments.permanence) {\n        mana++\n      }\n\n      if (this.spell.attainments.timeInABottle) {\n        mana++\n      }\n\n      if (this.spell.attainments.sympatheticRange) {\n        mana++\n      }\n\n      if (this.spell.attainments.temporalSympathy) {\n        mana++\n      }\n\n      if (this.spell.attainments.everywhere) {\n        mana++\n      }\n\n      mana += this.paradox.manaSpent\n\n      return mana\n    },\n    maxMana() {\n      return gnosisManaLimits[this.caster.gnosis]\n    },\n    // use this to watch attainments changing\n    attainmentsByName() {\n      let attainments = []\n\n      each(this.spell.attainments, (value, key) => {\n        if (value) {\n          attainments.push(key)\n        }\n      })\n\n      return attainments\n    },\n    isSympatheticYantraMissing() {\n      return (\n        (this.spell.attainments.sympatheticRange || this.spell.attainments.temporalSympathy) &&\n        !this.hasYantra(\"t3\") &&\n        !this.hasYantra(\"t4\") &&\n        !this.hasYantra(\"t5\")\n      )\n    },\n    isCastable() {\n      return !this.isDicePoolTooLow && !this.isSympatheticYantraMissing\n    },\n    baseCastingTime() {\n      for (let [key, value] of baseCastingTimes) {\n        if (this.caster.gnosis >= key) {\n          return value\n        }\n      }\n      return null\n    },\n    arcanaOptions() {\n      let options = arcanaNames.map((arcana) => {\n        return {\n          label: arcana,\n          value: arcana,\n        }\n      });\n      return options\n    },\n    choosePracticeValue() {\n      return this.spell.practice\n    },\n    choosePracticeOptions() {\n      let options = []\n      for (let practice of practices) {\n        options.push({\n          label: `${dots(practice.level)} ${practice.name}`,\n          value: practice,\n        })\n      }\n      return options\n    },\n    choosePrimaryFactorOptions() {\n      let options = [\"Duration\", \"Potency\"].map((factor) => {\n        return {\n          label: factor,\n          value: factor,\n        }\n      });\n      return options\n    },\n    standardCastingTimeOptions() {\n      let options = [],\n        i = 0\n\n      while (i++ <= 5) {\n        let increment = this.baseCastingTime.increment * i,\n          unit = this.baseCastingTime.unit + (increment !== 1 ? \"s\" : \"\"),\n          bonus = i - 1\n\n        options.push({\n          value: \"s\" + i,\n          label: `${increment} ${unit} (+${bonus} dice)`,\n        })\n      }\n\n      return options\n    },\n    castingTimeOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard (Ritual Casting)\",\n        key: \"standard\",\n        children: this.standardCastingTimeOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced (Quick Casting)\",\n        key: \"advanced\",\n        children: [{ value: \"a1\", label: \"1 Turn\" }],\n      })\n      return options\n    },\n    standardPotencyOptions() {\n      let options = [],\n        i = 0\n\n      while (i++ < 11) {\n        let penalty = (i - 1) * 2\n\n        if (this.isPrimaryFactor(\"Potency\")) {\n          penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n        }\n\n        if (penalty < 0) {\n          penalty = 0\n        }\n\n        options.push({\n          value: \"s\" + i,\n          label: `${i} (-${penalty} dice)`,\n        })\n      }\n\n      return options\n    },\n    advancedPotencyOptions() {\n      let options = []\n      let i = 0\n      while (i++ < 11) {\n        let penalty = (i - 1) * 2\n\n        if (this.isPrimaryFactor(\"Potency\")) {\n          penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n        }\n\n        if (penalty < 0) {\n          penalty = 0\n        }\n\n        options.push({\n          value: \"a\" + i,\n          label: `${i} (-${penalty} dice)`,\n        })\n      }\n\n      return options\n    },\n    potencyOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardPotencyOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedPotencyOptions,\n      })\n      return options\n    },\n    rangeOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: [{ value: \"s1\", label: \"Touch\" }],\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: [\n          { value: \"a1\", label: \"Sensory\" },\n          { value: \"a2\", label: \"Remote\" },\n        ],\n      })\n      return options\n    },\n    standardDurationOptions() {\n      let options = []\n\n      for (let [key, duration] of durations) {\n        if (key[0] === \"s\") {\n          let penalty = duration.penalty\n\n          if (this.isPrimaryFactor(\"Duration\")) {\n            penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n          }\n\n          if (penalty < 0) {\n            penalty = 0\n          }\n\n          options.push({\n            value: key,\n            successes: key[1],\n            time: duration.time,\n            label: `${duration.time} (-${penalty} dice)`,\n          })\n        }\n      }\n\n      return options\n    },\n    advancedDurationOptions() {\n      let options = []\n\n      for (let [key, duration] of durations) {\n        if (key[0] === \"a\") {\n          let penalty = duration.penalty\n\n          if (this.isPrimaryFactor(\"Duration\")) {\n            penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n          }\n\n          if (penalty < 0) {\n            penalty = 0\n          }\n\n          options.push({\n            value: key,\n            successes: key[1],\n            time: duration.time,\n            label: `${duration.time} (-${penalty} dice)`,\n          })\n        }\n      }\n\n      return options\n    },\n    durationOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardDurationOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedDurationOptions,\n      })\n      return options\n    },\n    standardScaleOptions() {\n      let options = []\n\n      for (let [key, scale] of scales) {\n        if (key[0] === \"s\") {\n          let s = clone(scale)\n          s.value = key\n          s.penalty = `-${scale.penalty}`\n          options.push(s)\n        }\n      }\n\n      return options\n    },\n    advancedScaleOptions() {\n      let options = []\n\n      for (let [key, scale] of scales) {\n        if (key[0] === \"a\") {\n          let s = clone(scale)\n          s.value = key\n          s.penalty = `-${scale.penalty}`\n          options.push(s)\n        }\n      }\n\n      return options\n    },\n    scaleOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardScaleOptions.map(({ value, number, size, area, penalty }) => {\n          return {\n            value: value,\n            label: `${number} subjects or ${area.toLowerCase()} (${penalty} dice)`,\n          }\n        }),\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedScaleOptions.map(({ value, number, size, area, penalty }) => {\n          return {\n            value: value,\n            label: `${number} subjects or ${area.toLowerCase()} (${penalty} dice)`,\n          }\n        }),\n      })\n      return options\n    },\n    locationYantraOptions() {\n      return this.getYantraOptions(\"l\")\n    },\n    actionYantraOptions() {\n      return this.getYantraOptions(\"a\")\n    },\n    toolYantraOptions() {\n      return this.getYantraOptions(\"t\")\n    },\n    yantraOptions() {\n      return [\n        { type: \"group\", label: \"Locations\", key: \"locations\", children: this.locationYantraOptions },\n        { type: \"group\", label: \"Actions\", key: \"actions\", children: this.actionYantraOptions },\n        { type: \"group\", label: \"Tools\", key: \"tools\", children: this.toolYantraOptions },\n      ]\n    },\n    casterPraxesSummary() {\n      let summary = this.caster.praxes.map(p => p.name);\n      if (summary.length === 0) return \"None\"\n      return summary.join(\", \")\n    },\n    casterRotesSummary() {\n      let summary = this.caster.rotes.map(p => p.name);\n      if (summary.length === 0) return \"None\"\n      if (summary.length === 1) return \"1 Spell\"\n      return `${summary.length} Spells`\n    },\n    gnosisSummary() {\n      let summary = \"\"\n      if (this.caster.gnosis > 0) summary += `Gnosis ${this.caster.gnosis}`\n      if (summary.length === 0) return \"None\"\n      return summary\n    },\n    arcanaSummary() {\n      let summary = []\n      for (let arcana in this.caster.arcana) {\n        let level = this.caster.arcana[arcana].level\n        if (level > 0) summary.push(`${arcana} ${level}`)\n      }\n      if (summary.length === 0) return \"None\"\n      return summary.join(\", \")\n    },\n    effectsSummary() {\n      let summary = []\n      if (this.spell.effects.length || this.spell.spendWillpower) summary.push(`${this.spell.effects.length + (this.spell.spendWillpower ? 1 : 0)}`)\n      if (this.spell.custom) {\n        if (this.spell.extraReach > 0 || this.spell.extraMana > 0) summary.push(\"Custom\")\n      }\n      if (summary.length === 0) return \"None\"\n      return \"Effects (\" + summary.join(\", \") + \")\"\n    },\n    conditionsSummary() {\n      let summary = []\n      if (this.conditions.bonusDice > 0) summary.push(`+${this.conditions.bonusDice} dice`)\n      if (this.conditions.activeSpells > 0) summary.push(`${this.conditions.activeSpells} active`)\n      if (this.conditions.subjectWithstand > 0) summary.push(`${this.conditions.subjectWithstand} withstand`)\n      if (summary.length === 0) return \"None\"\n      return summary.join(\", \")\n    },\n    spellSummary() {\n      let summary = \"\"\n      if (this.spell.name) summary += `${this.spell.name} (`\n      if (this.spell.primaryArcana?.arcana && this.spell.primaryArcana?.level) summary += `${this.spell.primaryArcana.arcana} ${this.spell.primaryArcana.level}`\n      if (this.spell.secondaryArcana?.arcana && this.spell.secondaryArcana?.level) summary += `, ${this.spell.secondaryArcana.arcana} ${this.spell.secondaryArcana.level}`\n      if (this.spell.name) summary += \")\"\n      if (summary.length === 0) return \"None\"\n      return summary\n    },\n    paradoxDiceSummary() {\n      let summary\n\n      if (this.paradoxDice === \"Chance\") {\n        summary = \"Chance\"\n      } else if (this.paradoxDice === 1) {\n        summary = this.paradoxDice + \" die\"\n      } else {\n        summary = this.paradoxDice + \" dice\"\n      }\n\n      if (this.paradox.sleepers > 0) {\n        if (this.paradox.sleepers === 2) {\n          summary += \" (9-again)\"\n        } else if (this.paradox.sleepers === 3) {\n          summary += \" (8-again)\"\n        } else if (this.paradox.sleepers === 4) {\n          summary += \" (as rote)\"\n        }\n      }\n\n      return summary\n    },\n    dicePoolSummary() {\n      if (this.dicePool < 1) {\n        return \"Chance\"\n      } else if (this.dicePool == 1) {\n        return `${this.dicePool} die`\n      } else {\n        return `${this.dicePool} dice`\n      }\n    },\n    castingTimeSummary() {\n      // standard\n      if (this.spell.factors.castingTime[0] === \"s\") {\n        let increment = this.baseCastingTime.increment * this.spell.factors.castingTime[1],\n          unit = this.baseCastingTime.unit + (increment !== 1 ? \"s\" : \"\")\n\n        return increment + \" \" + unit\n      }\n      // advanced\n      else {\n        let turns = this.numYantras <= 1 ? 1 : this.numYantras\n\n        if (this.hasYantra(\"a3\")) {\n          turns = turns == 1 ? 2 : turns\n        }\n\n        return `${turns} turn${turns !== 1 ? \"s\" : \"\"}`\n      }\n    },\n    durationSummary() {\n      return durations.get(this.spell.factors.duration).time\n    },\n    potencySummary() {\n      return this.potencyValue\n    },\n    rangeSummary() {\n      if (this.spell.factors.range === \"s1\") {\n        return \"Touch\"\n      } else if (\n        this.spell.attainments.sympatheticRange ||\n        this.spell.attainments.temporalSympathy\n      ) {\n        let range = []\n\n        if (this.spell.attainments.sympatheticRange) {\n          range.push(\"Sympathetic\")\n        }\n\n        if (this.spell.attainments.temporalSympathy) {\n          range.push(\"Temporal Sympathetic\")\n        }\n\n        return range.join(\" and \")\n      } else {\n        if (this.spell.factors.range === \"a1\") return \"Sensory\"\n        if (this.spell.factors.range === \"a2\") return \"Remote\"\n      }\n    },\n    scaleSummary() {\n      let scale = scales.get(this.spell.factors.scale)\n      return scale ? `${scale.number} subjects or ${scale.area.toLowerCase()}` : \"\"\n    },\n    scalePenalty() {\n      let scale = scales.get(this.spell.factors.scale)\n      return scale ? scale.penalty : \"\"\n    },\n    paradoxSummary() {\n      return this.paradoxDiceSummary\n    },\n    yantrasSummary() {\n      let yantrasNames = []\n\n      for (let yantra of this.spell.yantras) {\n        yantrasNames.push(this.yantras.get(yantra.yantraKey).name)\n      }\n      if (yantrasNames.length === 0) return \"None\"\n\n      return yantrasNames.join(\", \")\n    },\n    factorCastingTime() {\n      return this.spell.factors.castingTime\n    },\n    factorDuration() {\n      return this.spell.factors.duration\n    },\n    factorRange() {\n      return this.spell.factors.range\n    },\n    factorScale() {\n      return this.spell.factors.scale\n    },\n  },\n  watch: {\n    caster: {\n      handler(value) {\n        localStorage.setItem(\"caster\", JSON.stringify(value))\n        if (value && value.id && this.casters.find(c => c.id === value.id) === undefined) {\n          this.casters.push(value)\n        }\n      },\n      deep: true,\n    },\n    casters: {\n      handler(value) {\n        localStorage.setItem(\"casters\", JSON.stringify(value))\n      },\n      deep: true,\n    },\n    saved: {\n      handler(value) {\n        localStorage.setItem(\"saved\", JSON.stringify(value))\n      },\n      deep: true,\n    },\n    dark: {\n      handler(value) {\n        console.log('dark changed', value)\n        localStorage.setItem(\"dark\", JSON.stringify(value))\n      },\n    },\n    \"spell.isRote\": function (newer, older) {\n      if (older === true && newer === false && this.hasYantra(\"a1\")) {\n        this.deleteYantra(\"a1\")\n        this.message.warning(\"Rote Skill Mudra removed from yantras\")\n      }\n        // if (this.hasYantra(\"a1\") && spell.isRote === true) {\n        //   setTimeout(() => {\n        //     let yantra = spell.yantras.findIndex((y) => y.yantraKey === \"a1\")\n        //     if (yantra.bonus !== spell.roteSkill) {\n        //       this.message.info(\"Rote Skill Mudra updated to +\" + spell.roteSkill)\n        //       spell.yantras[yantra].bonus = spell.roteSkill\n        //     }\n        //   }, 250)\n        // }\n    },\n    \"spell.commonEffects.changePrimaryFactor\": function (newer, older) {\n      const current = this.spell.primaryFactor\n      if (newer === true && current === \"Potency\") this.spell.primaryFactor = \"Duration\"\n      if (newer === true && current === \"Duration\") this.spell.primaryFactor = \"Potency\"\n      if (newer === false && current === \"Duration\") this.spell.primaryFactor = \"Potency\"\n      if (newer === false && current === \"Potency\") this.spell.primaryFactor = \"Duration\"\n    },\n    \"conditions.subjectWithstand\": function (newer, older) {\n      let extraPotency = this.spell.factors.potency[1] - 1\n      let prefix = this.spell.factors.potency[0]\n      let minPotency = this.totalWithstand\n      let isStandard = prefix !== \"a\"\n\n      // Advanced Potency reduces Withstand by 2\n      if (!isStandard) minPotency -= 2\n\n      // Potency too low?\n      if (extraPotency < minPotency) {\n        this.spell.factors.potency = prefix + minPotency\n        this.message.info(`Potency (${prefix === \"s\" ? \"Standard\" : \"Advanced\"}) increased to ${minPotency}`)\n      }\n    },\n  },\n  methods: {\n    setDark(value) {\n      if (value === true) this.theme = darkTheme\n      if (value === false) this.theme = lightTheme\n    },\n    choosePractice(practice) {\n      this.spell.practice = practice.name\n      this.spell.primaryArcana.level = practice.level\n    },\n    createCaster() {\n      console.log('create caster')\n      if (this.chooseCasterDropdown) {\n        this.chooseCasterDropdown.blur()\n        this.chooseCasterDropdown.show = false\n        // this.chooseCasterValue = caster\n      }\n      let caster = { ...clone(defaultCaster), id: new Date().getTime() }\n      this.caster = caster\n      this.caster.rotes = []\n      this.caster.praxes = []\n    },\n    chooseCaster(caster) {\n      if (this.chooseCasterDropdown) {\n        this.chooseCasterDropdown.blur()\n        // this.chooseCasterValue = null\n      }\n      this.caster = caster\n      this.caster.rotes = caster.rotes\n      this.caster.praxes = caster.praxes\n    },\n    chooseYantraFromDropdown(option) {\n      if (this.chooseYantraDropdown) {\n        this.chooseYantraDropdown.blur()\n        this.chooseYantraValue = null\n      }\n      this.addYantra(option)\n    },\n    choosePraxisFromDropdown(option) {\n      if (this.choosePraxisDropdown) {\n        this.choosePraxisDropdown.blur()\n        this.choosePraxisValue = null\n      }\n      this.caster.praxes = this.caster.praxes || []\n      this.caster.praxes.push({\n        name: option.name,\n        arcana: option.primaryArcana.arcana,\n        level: option.primaryArcana.level,\n      });\n    },\n    chooseRoteFromDropdown(option) {\n      if (this.chooseRoteDropdown) {\n        this.chooseRoteDropdown.blur()\n        this.chooseRoteValue = null\n      }\n      this.caster.rotes = this.caster.rotes || []\n      this.caster.rotes.push({\n        name: option.name,\n        arcana: option.primaryArcana.arcana,\n        level: option.primaryArcana.level,\n        skill: 0,\n      });\n    },\n    hasPraxis(name) {\n      if (!this.caster.praxes) return false;\n      return this.caster.praxes.find((s) => s.name === name)\n    },\n    hasRote(name) {\n      if (!this.caster.rotes) return false;\n      return this.caster.rotes.find((s) => s.name === name)\n    },\n    removeCaster(id) {\n      let index = this.casters.findIndex((s) => s.id === id)\n      if (index !== -1) {\n        const name = this.casters[index].name\n        this.casters.splice(index, 1)\n        this.message.error(`${name} was removed`)\n        this.caster = null\n      }\n    },\n    removePraxisSpell(name) {\n      let index = this.caster.praxes.findIndex((s) => s.name === name)\n      if (index !== -1) this.caster.praxes.splice(index, 1)\n    },\n    removeRoteSpell(name) {\n      let index = this.caster.rotes.findIndex((s) => s.name === name)\n      if (index !== -1) this.caster.rotes.splice(index, 1)\n    },\n    renderYantraLabel(option) {\n      if (option.type === \"group\") return option.label\n      return h(\n        'div',\n        {\n          style: { padding: '4px 0' },\n        },\n        [\n          h('b', option.label),\n          h('br'),\n          option.disabledWarning || option.desc,\n        ]\n      )\n    },\n    customSpell(spell) {\n      const cloned = clone(defaultSpell)\n      this.spell = cloned\n      this.spell.custom = true\n      this.spell.customName = undefined\n      this.spell.primaryArcana.arcana = undefined\n      this.spell.primaryArcana.level = undefined\n      this.spell.secondaryArcana.arcana = undefined\n      this.spell.secondaryArcana.level = undefined\n      this.spell.primaryFactor = cloned.primaryFactor\n      this.spell.roteSkill = cloned.roteSkill\n      this.spell.roteSkills = cloned.roteSkills\n      this.spell.description = cloned.description\n      this.spell.additionalEffects = cloned.additionalEffects\n      this.spell.effects = []\n      this.spell.yantras = []\n      this.spell.factors = {\n        castingTime: \"s1\",\n        potency: \"s1\",\n        range: \"s1\",\n        duration: \"s1\",\n        scale: \"s1\",\n      }\n      this.spell.page = cloned.page\n      this.spell.isPraxis = false\n      this.spell.isRote = false\n      this.spell.roteSkill = undefined\n    },\n    applyCustomSpell(spell) {\n      this.spell.name = this.spell.customName\n    },\n    chooseSpell(spell) {\n      if (spell.name === \"Creative Thaumaturgy\") {\n        return this.customSpell(spell)\n      }\n      const cloned = clone(defaultSpell)\n      this.spell = cloned\n      this.spell.name = spell.name\n      this.spell.practice = spell.practice\n      this.spell.primaryArcana.arcana = spell.primaryArcana?.arcana\n      this.spell.primaryArcana.level = spell.primaryArcana?.level\n      this.spell.secondaryArcana.arcana = spell.secondaryArcana?.arcana\n      this.spell.secondaryArcana.level = spell.secondaryArcana?.level\n      this.spell.primaryFactor = spell.primaryFactor\n      this.spell.roteSkill = spell.roteSkill\n      this.spell.roteSkills = spell.roteSkills\n      this.spell.description = spell.description\n      this.spell.additionalEffects = spell.additionalEffects\n      this.spell.effects = []\n      this.spell.yantras = []\n      this.spell.factors = {\n        castingTime: \"s1\",\n        potency: \"s1\",\n        range: \"s1\",\n        duration: \"s1\",\n        scale: \"s1\",\n      }\n      this.spell.page = spell.page\n\n      const hasPraxis = this.hasPraxis(spell.name)\n      if (hasPraxis) {\n        this.spell.isPraxis = true\n      }\n\n      const hasRote = this.hasRote(spell.name)\n      if (hasRote) {\n        this.spell.isRote = true\n        this.spell.roteSkill = hasRote.skill\n      }\n    },\n    addCommonReachEffects() {\n      let effects = []\n      effects.push({\n        cost: [{ type: \"Reach\", value: 1 }],\n        effect: \"Change the primary factor\"\n      });\n      effects.push({\n        cost: [{ type: \"Reach\", value: 1 }],\n        requirement: [{ factor: \"Range\", value: \"a1\" }],\n        effect: \"Change the range to remote viewing\"\n      });\n      effects.push({\n        cost: [{ type: \"Reach\", value: 1 }],\n        requirement: [{ factor: \"Range\", value: \"a1\" }],\n        effect: \"Change the active spells limit\"\n      });\n      effects.push({\n        cost: [{ type: \"Reach\", value: 1 }, { type: \"Mana\", value: 1 }],\n        requirement: [{ factor: \"Duration\", value: \"a\" }],\n        effect: \"Change the duration to indefinite\"\n      });\n    },\n    dots(num) {\n      return Array.from({ length: num }, () => \"•\").join(\"\")\n    },\n    isAdvanced(factorName) {\n      return this.spell.factors[factorName][0] === \"a\"\n    },\n    isPrimaryFactor(factorName) {\n      return this.spell.primaryFactor === factorName\n    },\n    setRote(value) {\n      this.spell.isRote = value\n    },\n    setPraxis(value) {\n      this.spell.isPraxis = value\n    },\n    checkAttainments() {\n      // time in a bottle requires advanced\n      if (this.spell.attainments.timeInABottle && !this.isAdvanced(\"castingTime\")) {\n        // debounce(() => {\n        //   this.spell.attainments.timeInABottle = false\n        //   Toast.create(\n        //     \"Time in a Bottle attainment requires advanced Casting Time. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // permanence requires advanced\n      if (\n        this.spell.attainments.permanence &&\n        (this.spell.primaryArcana.arcana !== \"Matter\" || !this.isAdvanced(\"Duration\"))\n      ) {\n        // debounce(() => {\n        //   this.spell.attainments.permanence = false\n        //   Toast.create(\n        //     \"Permanence attainment requires advanced Duration. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // everywhere requires advanced\n      if (this.spell.attainments.everywhere && !this.isAdvanced(\"scale\")) {\n        // debounce(() => {\n        //   this.spell.attainments.everywhere = false\n        //   Toast.create(\n        //     \"Everywhere attainment requires advanced Scale. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // sympathy requires advanced\n      if (this.spell.attainments.sympatheticRange && !this.isAdvanced(\"range\")) {\n        // debounce(() => {\n        //   this.spell.attainments.sympatheticRange = false\n        //   Toast.create(\n        //     \"Sympathetic Range attainment requires advanced Range. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // temporal sympathy requires advanced\n      if (this.spell.attainments.temporalSympathy && !this.isAdvanced(\"range\")) {\n        // debounce(() => {\n        //   this.spell.attainments.temporalSympathy = false\n        //   Toast.create(\n        //     \"Temporal Sympathy attainment requires advanced Range. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n    },\n    isUniqueYantraUsed(key) {\n      let yantra = this.yantras.get(key)\n\n      // ignore non-uniques\n      if (!yantra.unique) {\n        return false\n      }\n\n      // this version is used?\n      if (this.hasYantra(key)) {\n        return true\n      }\n\n      // there are multiple version of this yantra - check for others\n      if (key.indexOf(\"_\") !== -1) {\n        let baseKey = key.split(\"_\")[0]\n        if (this.spell.yantras.some((yantra) => yantra.yantraKey.indexOf(baseKey) === 0)) {\n          return true\n        }\n      }\n\n      return false\n    },\n    getYantraOptions(prefix) {\n      let options = []\n\n      for (let [key, yantra] of this.yantras) {\n        if (key[0] === prefix) {\n          // 'l', 'a', or 't'\n          // disabled?\n          let disabledWarning\n\n          if (key === \"a1\" && this.spell.isRote === false) {\n            disabledWarning = \"Only available when casting Rotes.\"\n          }\n\n          if (key === \"a2\" && !this.isConcentrationMantraAllowed) {\n            disabledWarning = \"Duration must be more than 1 turn to use concentration.\"\n          }\n\n          if (this.isUniqueYantraUsed(key)) {\n            disabledWarning = \"Only one of this Yantra may be used.\"\n          }\n\n          if (key === \"t1\" && this.isDedicatedToolYantraUsed) {\n            disabledWarning = \"Dedicated Tool is already being used.\"\n          }\n\n          yantra.disabledWarning = disabledWarning\n          yantra.disabled = !!disabledWarning\n\n          // add to options\n          options.push(yantra)\n        }\n      }\n\n      return options\n    },\n    hasYantra(key) {\n      return some(this.spell.yantras, [\"yantraKey\", key]) // `_.matchesProperty` iteratee shorthand.\n    },\n    addYantra(key) {\n      let yantra = this.yantras.get(key)\n\n      this.spell.yantras.push(yantra)\n    },\n    deleteYantra(key) {\n      let index = findIndex(this.spell.yantras, (yantra) => yantra.yantraKey === key)\n      this.spell.yantras.splice(index, 1)\n    },\n    updateYantraIsDedicatedTool(key, newValue) {\n      let index = findIndex(this.spell.yantras, (yantra) => yantra.yantraKey === key)\n      this.spell.yantras[index].isDedicatedTool = newValue\n    },\n    isEffectRestricted(item) {\n      let answer = false\n      if (item.requirement) {\n        item.requirement.forEach(i => {\n          if (i.arcana) {\n            if (this.caster.arcana[i.arcana].level < i.value) answer = true\n          }\n          if (i.practice) {\n            if (this.spell.practice !== i.practice) answer = true\n          }\n        })\n      }\n      return answer\n    },\n    isEffectAdded(item) {\n      const existing = this.spell.effects.findIndex(added => added.effect === item.effect);\n      return existing !== -1\n    },\n    // Effects\n    toggleEffect(item) {\n      if (this.isEffectAdded(item)) {\n        this.spell.effects.splice(this.spell.effects.findIndex(added => added.effect === item.effect), 1)\n      } else {\n        this.spell.effects.push(item)\n      }\n    },\n    // Spell Stuff\n    getSpellWithSummary(spell) {\n      const item = clone(spell)\n      const itemCastingSummary = []\n      if (item.isRote) itemCastingSummary.push(\"Rote\")\n      if (item.isPraxis) itemCastingSummary.push(\"Praxis\")\n      itemCastingSummary.push(`${this.usedReach}/${this.freeReach} Reach`)\n      itemCastingSummary.push(`${this.dicePool} Dice`)\n      itemCastingSummary.push(`${this.totalMana} Mana`)\n      itemCastingSummary.push(`${this.paradoxDice} Paradox`)\n      const itemFactorSummary = [];\n      itemFactorSummary.push(`${this.potencySummary.toLowerCase()} potency`)\n      itemFactorSummary.push(`${this.durationSummary.toLowerCase()} duration`)\n      itemFactorSummary.push(`${this.castingTimeSummary.toLowerCase()} casting time`)\n      itemFactorSummary.push(`${this.rangeSummary.toLowerCase()} range`)\n      itemFactorSummary.push(`${this.scaleSummary.toLowerCase()}`)\n      const itemEffectSummary = item.effects.map(effect => effect.effect);\n      if (item.spendWillpower) itemEffectSummary.unshift(\"Willpower spent.\")\n      if (item.commonEffects.changePrimaryFactor) itemEffectSummary.push(\"Changed primary factor.\")\n      if (this.conditions.activeSpells >= this.caster.gnosis) itemEffectSummary.push(\"Casting above active limit.\")\n      if (item.custom) item.page = \"Creative, \" + item.practice\n      const itemYantraSummary = item.yantras.map(yantra => yantra.name);\n      const about = []\n      if (this.dicePool > 7) about.push(`easy`);\n      if (this.dicePool < 4) about.push(`hard`);\n      if (this.paradoxDice === 0) about.push(`safe`);\n      else if (typeof this.paradoxDice !== \"string\") about.push(`risky`);\n      if (item.factors.castingTime === \"a1\") about.push(\"quick\")\n      else if (Number(item.factors.castingTime[1]) > 3) about.push(\"slow\")\n      if (item.factors.duration[0] === \"s\") about.push(\"short\")\n      if (item.factors.duration[0] === \"a\") about.push(\"long\")\n      if (Number(item.factors.scale[1]) > 3) about.push(\"big\")\n      if (this.usedReach > 4) about.push(\"complex\")\n\n      item.id = new Date().getTime()\n      item.tags = {\n        method: this.roteOrPraxis,\n        reach: `${this.usedReach}/${this.freeReach}`,\n        dice: this.dicePool,\n        mana: this.totalMana,\n        paradox: this.paradoxDice,\n      }\n      item.summary = about.join(\", \")\n      item.castingSummary = itemCastingSummary.join(\", \")\n      item.factorSummary = itemFactorSummary.join(\", \")\n      item.effectSummary = itemEffectSummary.join(\" \")\n      item.yantraSummary = itemYantraSummary.join(\", \")\n      item.conditionSummary = this.conditionsSummary\n      item.actionSummary = this.dicePoolSummary\n      return item\n    },\n    putSpellMacroInClipboard(spell) {\n      const out = [];\n      out.push(\"&{template:default}\");\n      out.push(`{{name=**${spell.name}** (${spell.primaryArcana.arcana} ${Array.from({ length: spell.primaryArcana.level }, v => \"&bull;\").join(\"\")})}}`)\n      out.push(`{{summary=${spell.description}\\n(${spell.page})}}`)\n      out.push(`{{casting=${spell.castingSummary}}}`)\n      out.push(`{{factors=${spell.factorSummary}}}`)\n      out.push(`{{extras=${spell.effectSummary || \"None\"}}}`)\n      out.push(`{{yantras=${spell.yantraSummary || \"None\"}}}`)\n      if (spell.conditionSummary !== \"None\") out.push(`{{conditions=${spell.conditionSummary}}}`)\n      out.push(`{{=[Roll ${spell.actionSummary} to cast](!&#13;&#91;[&#63;{Number of dice|${spell.tags.dice}}d10>8!>&#63;{Explodes on|10}]&#93; Successes)}}`);\n      const text = out.join(\" \");\n      navigator.clipboard.writeText(text).then(() => {\n        this.message.info(`${spell.name} was copied to clipboard`)\n      });\n    },\n    copyActiveSpell() {\n      const spell = this.getSpellWithSummary(this.spell)\n      this.putSpellMacroInClipboard(spell)\n    },\n    copySavedSpell(spell) {\n      this.putSpellMacroInClipboard(spell)\n    },\n    removeSpell(spell) {\n      let index = findIndex(this.saved, (item) => item.id === spell.id)\n      this.saved.splice(index, 1)\n      this.message.error(`${spell.name} was removed`)\n    },\n    loadSpell(spell) {\n      const cloned = clone(spell)\n      this.spell = { ...cloned }\n      this.spell.primaryArcana.arcana = spell.primaryArcana.arcana;\n      this.spell.primaryArcana.level = spell.primaryArcana.level;\n      this.spell.secondaryArcana.arcana = spell.secondaryArcana.arcana;\n      this.spell.secondaryArcana.level = spell.secondaryArcana.level;\n      this.paradox = { ...clone(defaultParadox) }\n      this.conditions = { ...clone(defaultConditions) }\n      this.message.success(`${cloned.name} was loaded`)\n      if (cloned.conditionSummary !== \"None\") {\n        this.message.info(`Condition settings have been cleared`)\n      }\n      if (cloned.tags.paradox !== 0) {\n        this.message.info(`Paradox settings has been cleared`)\n      }\n    },\n    saveActiveSpell() {\n      const spell = this.getSpellWithSummary(this.spell)\n      this.saved.push(spell)\n      this.message.success(`${spell.name} was saved`)\n    },\n    reset() {\n      const cloned = clone(defaultSpell)\n      this.spell = { ...cloned }\n      this.spell.primaryArcana.arcana = undefined\n      this.spell.primaryArcana.level = undefined\n      this.spell.secondaryArcana.arcana = undefined\n      this.spell.secondaryArcana.level = undefined\n      this.spell.primaryFactor = cloned.primaryFactor\n      this.spell.roteSkill = cloned.roteSkill\n      this.spell.roteSkills = cloned.roteSkills\n      this.spell.description = cloned.description\n      this.spell.additionalEffects = []\n      this.spell.effects = []\n      this.spell.yantras = []\n      this.spell.factors = {\n        castingTime: \"s1\",\n        potency: \"s1\",\n        range: \"s1\",\n        duration: \"s1\",\n        scale: \"s1\",\n      }\n      this.paradox = { ...clone(defaultParadox) }\n      this.conditions = { ...clone(defaultConditions) }\n      this.message.warning(\"Spell config has been reset\")\n    },\n    log(text) {\n      console.log(text)\n    },\n  },\n  mounted() {\n    if (localStorage.getItem(\"caster\")) {\n      try {\n        let caster = JSON.parse(localStorage.getItem(\"caster\"))\n        if (caster) {\n          this.caster = caster\n          this.caster.id = this.caster.id || new Date().getTime()\n          this.caster.name = this.caster.name || \"You\"\n          this.caster.type = this.caster.type || \"Cabal\"\n          this.caster.praxes = this.caster.praxes || []\n          this.caster.rotes = this.caster.rotes || []\n        }\n      } catch (err) {\n        console.error(err)\n        localStorage.removeItem(\"caster\")\n      }\n    }\n    if (localStorage.getItem(\"casters\")) {\n      try {\n        const casters = JSON.parse(localStorage.getItem(\"casters\"))\n        this.casters = casters\n      } catch (err) {\n        console.error(err)\n        localStorage.removeItem(\"casters\")\n      }\n    }\n    if (localStorage.getItem(\"saved\")) {\n      try {\n        this.saved = JSON.parse(localStorage.getItem(\"saved\"))\n      } catch (err) {\n        console.error(err)\n        localStorage.removeItem(\"saved\")\n      }\n    }\n    if (localStorage.getItem(\"dark\")) {\n      try {\n        this.dark = JSON.parse(localStorage.getItem(\"dark\"))\n        this.setDark(this.dark)\n      } catch (err) {\n        console.error(err)\n        localStorage.removeItem(\"dark\")\n      }\n    }\n  },\n}\n</script>\n\n<style>\nhtml {\n  height: 100%;\n}\nbody {\n  height: 100%;\n  overflow: hidden;\n}\n.n-tabs .n-tabs-pane-wrapper {\n  overflow: visible;\n}\n.n-layout {\n  height: 100vh;\n}\n.n-tabs {\n  padding: 0 10px;\n  max-width: 600px;\n  margin: 80px auto;\n}\n.n-tabs .n-tabs-tab-pad {\n  width: 5px;\n}\n.n-tabs .n-tabs-tab {\n  padding: 10px;\n}\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n.s-table td {\n  vertical-align: middle;\n  line-height: 19px;\n}\n.s-table td .n-switch {\n  vertical-align: middle;\n}\n.n-card {\n  border-radius: 5px;\n  box-shadow: var(--n-box-shadow);\n}\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n.n-rate {\n  vertical-align: middle;\n}\n.n-rate__item svg circle {\n  stroke: var(--n-text-color);\n}\n.n-rate__item--active svg circle {\n  fill: var(--n-text-color);\n  stroke: var(--n-text-color);\n}\n.n-tabs-nav__suffix .n-switch.n-switch--active .n-switch__rail {\n    /* background-color: #f2c97d; */\n}\n.quick {\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 10;\n}\n.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n  position: fixed !important;\n  z-index: 10;\n}\n#spellAffix {\n  margin-bottom: -48px;\n  width: 100%;\n  max-width: 580px;\n}\n.btn-only-icon-when-small {\n  height: auto !important;\n}\n@media only screen\n  and (max-width: 600px) {\n  #spellAffix {\n    max-width: 100%;\n  }\n  #spellAffix.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n    max-width: calc(100% - 20px);\n  }\n  .btn-only-icon-when-small .n-button__icon { margin-right: 0; }\n  .btn-only-icon-when-small .n-button__content { display: none !important; }\n}\n.spellSummary {\n  height: 45px;\n}\n.spellSummary .n-card__content  {\n  padding: 10px !important;\n}\n.quick .n-card__content {\n  max-width: 600px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px !important;\n}\n#spellOptions {\n  position: fixed;\n  right: 10px;\n  bottom: 10px;\n  border-radius: 70px;\n  width: auto;\n}\n#spellOptions .n-card__content {\n  padding: 10px !important;\n}\n</style>\n"],"names":[],"version":3,"file":"index.47e6a91b.css.map"}