{"mappings":"ACyCA,+BAGA,uFAGA,2DAIA,wFAGA,sKASA,iEC20CA,iBAGA,qBAGA,2BAGA,0DAKA,mDAIA,uCAGA,sDAIA,8BAGA,qCAGA,uDAIA,2DDp4CA,+BAGA,uFAGA,2DAIA,wFAGA,sKASA,iEC20CA,iBAGA,qBAGA,2BAGA,0DAKA,mDAIA,uCAGA,sDAIA,8BAGA,qCAGA,uDAIA","sources":["index.e7e625e2.css","code/components/Card.vue","code/components/Main.vue"],"sourcesContent":[".card .n-card-header {\n  padding: 0;\n}\n\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content {\n  width: 100px;\n  flex: 1;\n}\n\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content .card-summary {\n  text-align: right;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex: 1;\n  font-size: 85%;\n  line-height: 1.5;\n  overflow: hidden;\n}\n\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n\nhtml {\n  height: 100%;\n}\n\nbody {\n  min-height: 100%;\n}\n\n.n-layout {\n  min-height: 100vh;\n}\n\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n\n.s-table td {\n  vertical-align: middle;\n  line-height: 20px;\n}\n\n.n-card {\n  box-shadow: var(--n-box-shadow);\n}\n\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n\n.n-rate {\n  vertical-align: middle;\n}\n\n.n-rate__item svg circle {\n  stroke: #000;\n}\n\n.n-rate__item--active svg circle {\n  fill: #000;\n  stroke: #000;\n}\n\n.bottom {\n  height: 70px;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.card .n-card-header {\n  padding: 0;\n}\n\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content {\n  width: 100px;\n  flex: 1;\n}\n\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content .card-summary {\n  text-align: right;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex: 1;\n  font-size: 85%;\n  line-height: 1.5;\n  overflow: hidden;\n}\n\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n\nhtml {\n  height: 100%;\n}\n\nbody {\n  min-height: 100%;\n}\n\n.n-layout {\n  min-height: 100vh;\n}\n\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n\n.s-table td {\n  vertical-align: middle;\n  line-height: 20px;\n}\n\n.n-card {\n  box-shadow: var(--n-box-shadow);\n}\n\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n\n.n-rate {\n  vertical-align: middle;\n}\n\n.n-rate__item svg circle {\n  stroke: #000;\n}\n\n.n-rate__item--active svg circle {\n  fill: #000;\n  stroke: #000;\n}\n\n.bottom {\n  height: 70px;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n/*# sourceMappingURL=index.e7e625e2.css.map */\n","<template>\n  <n-card size=\"small\" class=\"card\">\n    <template #header>\n      <n-button size=\"large\" text block @click=\"open = !open\">\n        <template #icon>\n          <n-icon>\n            <ChevronUp v-if=\"open == true\" />\n            <ChevronDown v-if=\"open === false\" />\n          </n-icon>\n        </template>\n        <n-text strong class=\"card-title\">{{ title }}</n-text>\n        <n-text depth=\"3\" class=\"card-summary\">{{ summary }}</n-text>\n      </n-button>\n    </template>\n    <template #default v-if=\"open === true\">\n      <slot name=\"content\"></slot>\n    </template>\n    <template #action v-if=\"open === true\">\n      <slot name=\"footer\"></slot>\n    </template>\n  </n-card>\n</template>\n\n<script>\nimport { ChevronDown, ChevronUp } from \"@vicons/ionicons5\"\n\nexport default {\n  components: { ChevronDown, ChevronUp },\n  props: [\"title\", \"summary\", \"collapsed\"],\n  data() {\n    return {\n      open: true,\n    }\n  },\n  mounted() {\n    if (this.collapsed !== undefined) this.open = false\n  },\n}\n</script>\n\n<style>\n.card .n-card-header {\n  padding: 0;\n}\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n.card .n-card-header .n-button__content {\n  flex: 1;\n  width: 100px;\n}\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n.card .n-card-header .n-button__content .card-summary {\n  flex: 1;\n  text-align: right;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 85%;\n  line-height: 1.5;\n}\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n</style>\n","<template>\n  <n-config-provider :theme-overrides=\"{ common: { fontWeightStrong: '600' } }\">\n    <n-layout\n      static\n      embedded\n      content-style=\"padding: 30px; padding-bottom: 100px; max-width: 600px; margin: 0 auto\"\n    >\n      <n-space vertical>\n        <!-- Caster -->\n        <Card title=\"Caster\" :summary=\"casterSummary\">\n          <template #content>\n            <n-space vertical>\n              <n-table striped class=\"s-table\">\n                <thead>\n                  <tr>\n                    <th>Gnosis</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  <tr>\n                    <td>\n                      <n-rate clearable :count=\"10\" v-model:value=\"caster.gnosis\">\n                        <n-icon>\n                          <EllipseOutline />\n                        </n-icon>\n                      </n-rate>\n                    </td>\n                  </tr>\n                </tbody>\n              </n-table>\n              <n-table striped class=\"s-table\">\n                <thead>\n                  <tr>\n                    <th width=\"40\">Arcana</th>\n                    <th width=\"35\"></th>\n                    <th>Level</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  <tr v-for=\"(item, name) of caster.arcana\" :key=\"name\">\n                    <td>\n                      <n-text>{{ name }}</n-text>\n                    </td>\n                    <td>\n                      <n-switch size=\"small\" v-model:value=\"item.ruling\" />\n                    </td>\n                    <td>\n                      <n-rate clearable :count=\"5\" v-model:value=\"item.level\">\n                        <n-icon>\n                          <EllipseOutline />\n                        </n-icon>\n                      </n-rate>\n                    </td>\n                  </tr>\n                </tbody>\n              </n-table>\n            </n-space>\n          </template>\n        </Card>\n        <!-- Warning if the caster has not been configured -->\n        <n-alert type=\"info\" v-if=\"hasConfiguredCaster === false\">\n          You must configure your caster (gnosis, arcana) before choosing a spell.\n        </n-alert>\n        <!-- Spell -->\n        <Card title=\"Spell\" :summary=\"spellSummary\" v-if=\"hasConfiguredCaster\">\n          <template #content>\n            <n-space vertical>\n              <n-select\n                filterable\n                placeholder=\"What spell are you casting?\"\n                :value=\"spell.name\"\n                @update-value=\"chooseSpell\"\n                :options=\"chooseSpellOptions\"\n              />\n            </n-space>\n          </template>\n          <template #footer v-if=\"spell.name\">\n            <n-space vertical>\n              <n-text italic depth=\"2\" v-html=\"spell.description\" />\n              <n-text italic depth=\"2\" v-for=\"(item, index) of spell.reachEffects\" :key=\"index\">\n                <b>+{{ item.reach }} Reach:</b> {{ item.effect }}\n              </n-text>\n              <n-text italic depth=\"2\">\n                <b style=\"text-transform: capitalize\">{{ spell.primaryFactor }}</b> is the primary\n                factor for this spell and is boosted up to the caster's {{ spell.arcana }} rating\n                without incurring a penalty.\n              </n-text>\n            </n-space>\n          </template>\n        </Card>\n        <!-- Method -->\n        <Card title=\"Method\" :summary=\"methodSummary\" v-if=\"canCastSpell\">\n          <template #content>\n            <n-space vertical>\n              <n-space>\n                <n-switch size=\"small\" v-model:value=\"spell.isPraxis\" @change=\"setRote(false)\" />\n                <n-text strong style=\"vertical-align: middle; line-height: 14px\">Praxis</n-text>\n              </n-space>\n              <n-space>\n                <n-switch size=\"small\" v-model:value=\"spell.isRote\" @change=\"setPraxis(false)\" />\n                <n-text strong style=\"vertical-align: middle; line-height: 14px\"> Rote </n-text>\n                <n-rate v-if=\"spell.isRote\" clearable :count=\"10\" v-model:value=\"spell.roteSkill\">\n                  <n-icon>\n                    <EllipseOutline />\n                  </n-icon>\n                </n-rate>\n              </n-space>\n              <n-space>\n                <n-switch size=\"small\" v-model:value=\"spell.spendWillpower\" />\n                <n-text strong>Spend willpower (+3 dice)</n-text>\n              </n-space>\n            </n-space>\n          </template>\n          <template #footer>\n            Bonus spellcasting dice widget goes here<br />\n            Number of active other spells widget goes here\n          </template>\n        </Card>\n        <!-- Warning if this spell cannot be cast -->\n        <n-alert type=\"warning\" v-if=\"spell.name && isSpellArcanaTooHigh\">\n          You need {{ spell.arcana }} {{ dots(spell.level) }} to cast this spell\n        </n-alert>\n        <!-- Potency -->\n        <Card title=\"Potency\" collapsed :summary=\"potencySummary\" v-if=\"canCastSpell\">\n          <template #content>\n            <n-select v-model:value=\"spell.factors.potency\" :options=\"potencyOptions\" />\n          </template>\n          <template #footer> Advanced Potency grants an additional -2 to Withstand. </template>\n        </Card>\n        <!-- Duration -->\n        <Card title=\"Duration\" collapsed :summary=\"durationSummary\" v-if=\"canCastSpell\">\n          <template #content>\n            <n-select v-model:value=\"spell.factors.duration\" :options=\"durationOptions\" />\n          </template>\n          <template #footer v-if=\"spell.factors.duration === 'a6'\">\n            Indefinite duration requires +1 Reach and +1 Mana\n          </template>\n        </Card>\n        <!-- Casting Time -->\n        <Card title=\"Casting Time\" collapsed :summary=\"castingTimeSummary\" v-if=\"canCastSpell\">\n          <template #content>\n            <n-select v-model:value=\"spell.factors.castingTime\" :options=\"castingTimeOptions\" />\n          </template>\n          <template #footer v-if=\"isAdvanced('castingTime')\">\n            Using more than one Yantra (or High Speech) will increase this time.\n          </template>\n        </Card>\n        <!-- Range -->\n        <Card title=\"Range\" collapsed :summary=\"rangeSummary\" v-if=\"canCastSpell\">\n          <template #content>\n            <n-select v-model:value=\"spell.factors.range\" :options=\"rangeOptions\" />\n          </template>\n        </Card>\n        <!-- Scale -->\n        <Card title=\"Scale\" collapsed :summary=\"scaleSummary\" v-if=\"canCastSpell\">\n          <template #content>\n            <n-select v-model:value=\"spell.factors.scale\" :options=\"scaleOptions\" />\n          </template>\n          <template #footer>\n            Advanced Scale doubles the number of subjects and adds 5 size per additional -2 dice\n            penalty.\n          </template>\n        </Card>\n        <!-- Yantras -->\n        <Card title=\"Yantras\" collapsed :summary=\"yantrasSummary\" v-if=\"canCastSpell\">\n          <template #content>\n            <n-space vertical>\n              <n-table\n                v-for=\"(group, name) of {\n                  Locations: locationYantraOptions,\n                  Actions: actionYantraOptions,\n                  Tools: toolYantraOptions,\n                }\"\n                :key=\"name\"\n                striped\n              >\n                <thead>\n                  <tr>\n                    <th>{{ name }}</th>\n                    <th width=\"80\"></th>\n                  </tr>\n                </thead>\n                <tbody>\n                  <tr v-for=\"yantra in group\" :key=\"yantra.yantraKey\">\n                    <td>\n                      <n-text strong>{{ yantra.name }} (+{{ yantra.bonus }})</n-text><br />\n                      <n-text v-html=\"yantra.desc\" />\n                    </td>\n                    <td v-if=\"hasYantra(yantra.yantraKey) === true\">\n                      <n-button\n                        block\n                        secondary\n                        type=\"error\"\n                        @click=\"deleteYantra(yantra.yantraKey)\"\n                      >\n                        Remove\n                      </n-button>\n                    </td>\n                    <td v-if=\"hasYantra(yantra.yantraKey) === false\">\n                      <n-tooltip\n                        :trigger=\"\n                          !!yantra.disabledWarning || numYantras === maxYantras ? 'hover' : 'manual'\n                        \"\n                      >\n                        <template #trigger>\n                          <n-button\n                            block\n                            secondary\n                            :type=\"\n                              !!yantra.disabledWarning || numYantras === maxYantras\n                                ? 'tertiary'\n                                : 'success'\n                            \"\n                            @click=\"\n                              !yantra.disabledWarning && numYantras < maxYantras\n                                ? addYantraFromModal(yantra.yantraKey)\n                                : undefined\n                            \"\n                          >\n                            Add\n                          </n-button>\n                        </template>\n                        <span v-if=\"numYantras === maxYantras\">\n                          You cannot have more than {{ maxYantras }} yantras\n                        </span>\n                        <span v-if=\"numYantras !== maxYantras\">\n                          {{ yantra.disabledWarning }}\n                        </span>\n                      </n-tooltip>\n                    </td>\n                  </tr>\n                </tbody>\n              </n-table>\n            </n-space>\n          </template>\n          <template #footer>\n            Gnosis {{ caster.gnosis }} allows the use of {{ maxYantras }} yantras.\n          </template>\n        </Card>\n      </n-space>\n    </n-layout>\n    <n-card class=\"bottom\">\n      <n-space horizontal size=\"small\" v-if=\"canCastSpell\">\n        <n-tag :bordered=\"false\" round strong :type=\"usedReach > freeReach ? 'warning' : 'success'\">\n          Reach {{ usedReach }}/{{ freeReach }}\n        </n-tag>\n        <n-tag :bordered=\"false\" round strong :type=\"isDicePoolTooLow ? 'warning' : 'success'\"\n          >Dice Pool {{ dicePool }}</n-tag\n        >\n        <n-tag :bordered=\"false\" round strong type=\"success\">Mana {{ totalMana }}</n-tag>\n        <n-tag v-if=\"hasParadox\" :bordered=\"false\" round strong type=\"error\">\n          Paradox {{ paradoxDice }}\n        </n-tag>\n      </n-space>\n    </n-card>\n  </n-config-provider>\n</template>\n\n<script>\nimport { clone, max, some, capitalize, findIndex, range } from \"lodash\"\nimport { useMessage } from \"naive-ui\"\nimport { darkTheme } from \"naive-ui\"\n\nimport { Close, ChevronDown, ChevronUp, Ellipse, EllipseOutline } from \"@vicons/ionicons5\"\n\nimport Card from \"./Card.vue\"\n\nimport {\n  arcanaNames,\n  baseCastingTimes,\n  castingMethods,\n  factors,\n  gnosisManaLimits,\n  durations,\n  scales,\n  yantrasBaseData,\n} from \"../constants/constants.js\"\nimport { spells } from \"../constants/spells.js\"\n\nfunction dots(num) {\n  return Array.from({ length: num }, () => \"•\").join(\"\")\n}\n\nexport default {\n  components: { Card, Close, ChevronDown, ChevronUp, Ellipse, EllipseOutline },\n  setup() {\n    return {\n      darkTheme,\n      theme: darkTheme,\n    }\n  },\n  data() {\n    return {\n      caster: {\n        gnosis: 0,\n        arcana: {\n          Death: { level: 0, ruling: false },\n          Fate: { level: 0, ruling: false },\n          Forces: { level: 0, ruling: false },\n          Life: { level: 0, ruling: false },\n          Matter: { level: 0, ruling: false },\n          Mind: { level: 0, ruling: false },\n          Prime: { level: 0, ruling: false },\n          Spirit: { level: 0, ruling: false },\n          Space: { level: 0, ruling: false },\n          Time: { level: 0, ruling: false },\n        },\n        activeSpells: 0,\n      },\n      spell: {\n        name: undefined,\n        arcana: undefined,\n        level: undefined,\n        isRote: false,\n        isPraxis: false,\n        practice: undefined,\n        primaryFactor: undefined,\n        primaryArcana: undefined,\n        secondaryArcana: undefined,\n        suggestedRoteSkills: undefined,\n        description: undefined,\n        reachEffects: [],\n        source: undefined,\n        factors: {\n          castingTime: \"s1\",\n          potency: \"s1\",\n          range: \"s1\",\n          duration: \"s1\",\n          scale: \"s1\",\n        },\n        roteSkill: 0,\n        bonusDice: 0,\n        spendWillpower: false,\n        extraReach: 0,\n        yantras: [],\n        yantraAlsoDedicatedTool: null,\n        attainments: {\n          conditionalDuration: false,\n          everywhere: false,\n          permanence: false,\n          sympatheticRange: false,\n          temporalSympathy: false,\n          timeInABottle: false,\n        },\n      },\n      subject: {\n        isResisted: false,\n        withstand: 1,\n        numWithstands: 1,\n      },\n      paradox: {\n        inured: false,\n        previousRolls: 0,\n        sleepers: false,\n        sleeperGroupSize: \"on\",\n        manaSpent: 0,\n      },\n      showCasterModal: false,\n      showMethodModal: false,\n      showPotencyModal: false,\n      showDurationModal: false,\n      showCastingTimeModal: false,\n      showRangeModal: false,\n      showScaleModal: false,\n      showYantrasModal: false,\n      theme: darkTheme.darkTheme,\n    }\n  },\n  computed: {\n    hasConfiguredCaster() {\n      return this.caster.gnosis > 0 && this.highestCasterArcana.length > 0\n    },\n    canCastSpell() {\n      if (this.spell.name === undefined) return false\n      if (this.isSpellArcanaTooHigh === true) return false\n      return true\n    },\n    chooseSpellValue() {\n      const spell = this.spell\n      if (spell.name && spell.arcana && spell.level) {\n        return spell.name\n        // return `${spell.name} (${spell.arcana} ${dots(spell.level)})`\n      }\n      return undefined\n    },\n    chooseSpellOptions() {\n      let options = []\n\n      for (let arcanaName of arcanaNames) {\n        options.push({\n          type: \"group\",\n          label: arcanaName,\n          key: arcanaName,\n          children: spells\n            .filter((s) => s.arcana === arcanaName)\n            .sort((a, b) => a.level < b.level)\n            .map((s) => {\n              return {\n                label: `${dots(s.level)} ${s.name}`,\n                value: s,\n              }\n            }),\n        })\n      }\n\n      return options\n    },\n    methodOptions() {\n      let options = []\n\n      for (let method of castingMethods) {\n        options.push({\n          label: method,\n          value: method,\n        })\n      }\n\n      return options\n    },\n    arcanaNameOptions() {\n      let options = []\n\n      for (let arcanaName of arcanaNames) {\n        options.push({\n          label: arcanaName,\n          value: arcanaName,\n        })\n      }\n\n      return options\n    },\n    highestCasterArcana() {\n      let highest = max(Object.values(this.caster.arcana).map((a) => a.level))\n      let arcanas = []\n      if (highest === 0) return arcanas\n      for (let arcana in this.caster.arcana) {\n        if (this.caster.arcana[arcana].level === highest) arcanas.push(arcana)\n      }\n      return arcanas\n    },\n    maxCasterArcana() {\n      let arcana\n\n      if (this.highestCasterArcana.includes(this.spell.arcana)) {\n        if (this.caster.gnosis >= 5) {\n          arcana = 5\n        } else if (this.caster.gnosis >= 3) {\n          arcana = 4\n        } else {\n          arcana = 3\n        }\n      } else {\n        if (this.caster.gnosis >= 6) {\n          arcana = 5\n        } else if (this.caster.gnosis >= 4) {\n          arcana = 4\n        } else {\n          arcana = 3\n        }\n      }\n\n      return arcana\n    },\n    isCasterArcanaTooHigh() {\n      return this.caster.arcana[this.spell.arcana].level > this.maxCasterArcana\n    },\n    isSpellArcanaTooHigh() {\n      return this.caster.arcana[this.spell.arcana].level < this.spell.level\n    },\n    freeReach() {\n      let arcana\n\n      if (this.spell.isRote) {\n        arcana = 5\n      } else {\n        arcana = this.caster.arcana[this.spell.arcana].level\n      }\n\n      return arcana - this.spell.level + 1\n    },\n    usedReach() {\n      let reach = 0\n\n      if (this.caster.activeSpells >= this.caster.gnosis) {\n        reach += this.caster.activeSpells - this.caster.gnosis + 1\n      }\n\n      // check factors (advanced factor keys begin with \"a\")\n      for (let factor of factors) {\n        if (this.spell.factors[factor][0] === \"a\") {\n          reach++\n        }\n      }\n\n      // indefinite duration costs 1 reach\n      if (!this.isPrimaryFactor(\"duration\") && this.spell.factors.duration === \"a6\") {\n        reach++\n      }\n\n      // spell-specific extra reach\n      reach += this.spell.extraReach\n\n      if (this.spell.attainments.permanence) {\n        reach--\n      }\n\n      if (this.spell.attainments.timeInABottle) {\n        reach--\n      }\n\n      if (this.spell.attainments.everywhere) {\n        reach--\n      }\n\n      return reach\n    },\n    roteOrPraxis() {\n      if (this.spell.isRote) {\n        return \"rote\"\n      } else if (this.spell.isPraxis) {\n        return \"praxis\"\n      } else {\n        return null\n      }\n    },\n    baseParadoxDice() {\n      return Math.ceil(this.caster.gnosis / 2)\n    },\n    paradoxDice() {\n      let pool, mustRoll\n\n      pool = 0\n      mustRoll = false\n\n      if (this.usedReach > this.freeReach) {\n        pool += (this.freeReach - this.usedReach) * -1\n        mustRoll = true\n      }\n\n      // gnosis multiplies paradox from additional reach\n      pool *= this.baseParadoxDice\n\n      if (this.paradox.inured) {\n        pool += 2\n        mustRoll = true\n      }\n\n      if (this.paradox.previousRolls > 0) {\n        pool += this.paradox.previousRolls\n        mustRoll = true\n      }\n\n      if (this.paradox.sleepers) {\n        pool++\n        mustRoll = true\n      }\n\n      if (this.isDedicatedToolYantraUsed) {\n        pool -= 2\n      }\n\n      pool -= this.paradox.manaSpent\n\n      if (pool <= 0 && mustRoll) {\n        return \"[chance die]\"\n      }\n\n      return pool\n    },\n    hasParadox() {\n      return (\n        this.usedReach > this.freeReach ||\n        this.paradox.inured ||\n        this.paradox.previousRolls > 0 ||\n        this.paradox.sleepers\n      )\n    },\n    durationPenalty() {\n      let penalty = durations.get(this.spell.factors.duration).penalty\n\n      if (this.isPrimaryFactor(\"duration\")) {\n        penalty -= (this.caster.arcana[this.spell.arcana].level - 1) * 2\n      }\n\n      if (penalty <= 0) {\n        penalty = 0\n      }\n\n      return penalty\n    },\n    potencyValue() {\n      return this.spell.factors.potency.substr(1)\n    },\n    potencyPenalty() {\n      let penalty = (this.potencyValue - 1) * 2\n\n      if (this.isPrimaryFactor(\"potency\")) {\n        penalty -= (this.caster.arcana[this.spell.arcana].level - 1) * 2\n      }\n\n      if (penalty <= 0) {\n        penalty = 0\n      }\n\n      return penalty\n    },\n    dicePool() {\n      // base pool\n      let pool = this.caster.gnosis + this.caster.arcana[this.spell.arcana].level\n\n      pool += this.spell.bonusDice\n\n      if (this.spell.spendWillpower) {\n        pool += 3\n      }\n\n      // casting time\n      if (!this.isAdvanced(\"castingTime\")) {\n        pool += this.spell.factors.castingTime[1] - 1\n      }\n\n      // potency\n      pool -= this.potencyPenalty\n\n      // duration\n      pool -= this.durationPenalty\n\n      // scale\n      pool -= scales.get(this.spell.factors.scale).penalty\n\n      // yantras\n      this.spell.yantras.forEach((yantra) => {\n        pool += yantra.bonus\n      })\n\n      return pool\n    },\n    isDicePoolTooLow() {\n      return this.dicePool < 1\n    },\n    spellFactorOptions() {\n      return [\n        {\n          label: \"Duration\",\n          value: \"duration\",\n        },\n        {\n          label: \"Potency\",\n          value: \"potency\",\n        },\n      ]\n    },\n    primaryFactor() {\n      return this.spell.primaryFactor\n    },\n    primaryFactorLabel() {\n      return capitalize(this.spell.primaryFactor)\n    },\n    totalWithstand() {\n      if (!this.subject.isResisted) {\n        return 0\n      }\n\n      let withstand = this.subject.withstand + this.subject.numWithstands - 1\n\n      if (this.spell.factors.potency === \"a1\") {\n        withstand -= 2\n      }\n\n      return withstand\n    },\n    yantras() {\n      let expandedYantras = new Map()\n\n      for (let [key, yantraBaseData] of yantrasBaseData) {\n        // bonus can contain a single number or a range. Arrayify.\n        let bonuses\n        if (Array.isArray(yantraBaseData.bonus)) {\n          bonuses = range(yantraBaseData.bonus[0], yantraBaseData.bonus[1] + 1)\n        } else {\n          bonuses = [yantraBaseData.bonus]\n        }\n\n        bonuses.forEach((bonus) => {\n          let expandedYantra = clone(yantraBaseData)\n\n          /*\n           * Bonus\n           */\n\n          // rote skill mudra: bonus = skill dots\n          if (key === \"a1\" && this.spell.isRote) {\n            bonus = this.spell.roteSkill\n          }\n\n          // sympathetic yantras don't give a bonus to sympathetic or temporal spells\n          if (\n            [\"t4\", \"t5\"].includes(key) &&\n            (this.spell.attainments.sympatheticRange || this.spell.attainments.temporalSympathy)\n          ) {\n            bonus = 0\n          }\n\n          expandedYantra.yantraKey = Array.isArray(yantraBaseData.bonus) ? key + \"_\" + bonus : key // key is a reserved property in Vue so we use \"yantraKey\"\n          expandedYantra.bonus = bonus\n          expandedYantra.label = `${yantraBaseData.name} (+${bonus} ${\n            bonus === 1 ? \"die\" : \"dice\"\n          })`\n          expandedYantra.isDedicatedTool = false\n          expandedYantras.set(expandedYantra.yantraKey, expandedYantra)\n        })\n      }\n\n      return expandedYantras\n    },\n    maxYantras() {\n      return Math.ceil(this.caster.gnosis / 2) + 1\n    },\n    numYantras() {\n      return this.spell.yantras.length\n    },\n    isConcentrationMantraAllowed() {\n      return this.isPrimaryFactor(\"duration\") || this.spell.factors.duration !== \"s1\"\n    },\n    isDedicatedToolYantraUsed: {\n      cache: false,\n      // getter\n      get() {\n        if (this.hasYantra(\"t1\")) {\n          return true\n        }\n\n        return some(this.spell.yantras, [\"isDedicatedTool\", true])\n      },\n      // setter (bool)\n      set(isUsed) {\n        if (isUsed) {\n          if (this.isDedicatedToolYantraUsed) {\n            // debounce(() => {\n            //   Toast.create(\"A Dedicated Tool is already selected\")\n            // })()\n          }\n\n          this.spell.yantras.push(this.yantras.get(\"t1\"))\n        } else {\n          this.deleteYantra(\"t1\")\n\n          for (let key of this.spell.yantras) {\n            this.spell.yantras[key].isDedicatedTool = false\n          }\n\n          this.$forceUpdate() // cache: false and this.$forceUpdate() means the getter shows updated value\n        }\n      },\n    },\n    totalMana() {\n      let mana = 0\n\n      if (\n        !this.caster.isRulingArcana &&\n        this.spell.method !== \"Rote\" &&\n        this.spell.method !== \"Praxis\"\n      ) {\n        mana++\n      }\n\n      if (this.spell.factors.duration === \"a6\") {\n        mana++\n      }\n\n      if (this.spell.attainments.permanence) {\n        mana++\n      }\n\n      if (this.spell.attainments.timeInABottle) {\n        mana++\n      }\n\n      if (this.spell.attainments.sympatheticRange) {\n        mana++\n      }\n\n      if (this.spell.attainments.temporalSympathy) {\n        mana++\n      }\n\n      if (this.spell.attainments.everywhere) {\n        mana++\n      }\n\n      mana += this.paradox.manaSpent\n\n      return mana\n    },\n    maxMana() {\n      return gnosisManaLimits[this.caster.gnosis]\n    },\n    // use this to watch attainments changing\n    attainmentsByName() {\n      let attainments = []\n\n      each(this.spell.attainments, (value, key) => {\n        if (value) {\n          attainments.push(key)\n        }\n      })\n\n      return attainments\n    },\n    isSympatheticYantraMissing() {\n      return (\n        (this.spell.attainments.sympatheticRange || this.spell.attainments.temporalSympathy) &&\n        !this.hasYantra(\"t3\") &&\n        !this.hasYantra(\"t4\") &&\n        !this.hasYantra(\"t5\")\n      )\n    },\n    isCastable() {\n      return !this.isDicePoolTooLow && !this.isSympatheticYantraMissing\n    },\n    baseCastingTime() {\n      for (let [key, value] of baseCastingTimes) {\n        if (this.caster.gnosis >= key) {\n          return value\n        }\n      }\n      return null\n    },\n    standardCastingTimeOptions() {\n      let options = [],\n        i = 0\n\n      while (i++ <= 5) {\n        let increment = this.baseCastingTime.increment * i,\n          unit = this.baseCastingTime.unit + (increment !== 1 ? \"s\" : \"\"),\n          bonus = i - 1\n\n        options.push({\n          value: \"s\" + i,\n          label: `${increment} ${unit} (+${bonus} dice)`,\n        })\n      }\n\n      return options\n    },\n    castingTimeOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard (Ritual Casting)\",\n        key: \"standard\",\n        children: this.standardCastingTimeOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced (Quick Casting)\",\n        key: \"advanced\",\n        children: [{ value: \"a1\", label: \"1 Turn\" }],\n      })\n      return options\n    },\n    standardPotencyOptions() {\n      let options = [],\n        i = 0\n\n      while (i++ < 11) {\n        let penalty = (i - 1) * 2\n\n        if (this.isPrimaryFactor(\"potency\")) {\n          penalty -= (this.caster.arcana[this.spell.arcana].level - 1) * 2\n        }\n\n        if (penalty < 0) {\n          penalty = 0\n        }\n\n        options.push({\n          value: \"s\" + i,\n          label: `${i} (-${penalty} dice)`,\n        })\n      }\n\n      return options\n    },\n    advancedPotencyOptions() {\n      let options = []\n      let i = 0\n      while (i++ < 11) {\n        let penalty = (i - 1) * 2\n\n        if (this.isPrimaryFactor(\"potency\")) {\n          penalty -= (this.caster.arcana[this.spell.arcana].level - 1) * 2\n        }\n\n        if (penalty < 0) {\n          penalty = 0\n        }\n\n        options.push({\n          value: \"a\" + i,\n          label: `${i} (-${penalty} dice)`,\n        })\n      }\n\n      return options\n    },\n    potencyOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardPotencyOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedPotencyOptions,\n      })\n      return options\n    },\n    rangeOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: [{ value: \"s1\", label: \"Touch/Aimed\" }],\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: [{ value: \"a1\", label: \"Sensory\" }],\n      })\n      return options\n    },\n    standardDurationOptions() {\n      let options = []\n\n      for (let [key, duration] of durations) {\n        if (key[0] === \"s\") {\n          let penalty = duration.penalty\n\n          if (this.isPrimaryFactor(\"duration\")) {\n            penalty -= (this.caster.arcana[this.spell.arcana].level - 1) * 2\n          }\n\n          if (penalty < 0) {\n            penalty = 0\n          }\n\n          options.push({\n            value: key,\n            successes: key[1],\n            time: duration.time,\n            label: `${duration.time} (-${penalty} dice)`,\n          })\n        }\n      }\n\n      return options\n    },\n    advancedDurationOptions() {\n      let options = []\n\n      for (let [key, duration] of durations) {\n        if (key[0] === \"a\") {\n          let penalty = duration.penalty\n\n          if (this.isPrimaryFactor(\"duration\")) {\n            penalty -= (this.caster.arcana[this.spell.arcana].level - 1) * 2\n          }\n\n          if (penalty < 0) {\n            penalty = 0\n          }\n\n          options.push({\n            value: key,\n            successes: key[1],\n            time: duration.time,\n            label: `${duration.time} (-${penalty} dice)`,\n          })\n        }\n      }\n\n      return options\n    },\n    durationOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardDurationOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedDurationOptions,\n      })\n      return options\n    },\n    standardScaleOptions() {\n      let options = []\n\n      for (let [key, scale] of scales) {\n        if (key[0] === \"s\") {\n          let s = clone(scale)\n          s.value = key\n          s.penalty = `-${scale.penalty}`\n          options.push(s)\n        }\n      }\n\n      return options\n    },\n    advancedScaleOptions() {\n      let options = []\n\n      for (let [key, scale] of scales) {\n        if (key[0] === \"a\") {\n          let s = clone(scale)\n          s.value = key\n          s.penalty = `-${scale.penalty}`\n          options.push(s)\n        }\n      }\n\n      return options\n    },\n    scaleOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardScaleOptions.map(({ value, number, size, area, penalty }) => {\n          return {\n            value: value,\n            label: `${number} subjects, ${area.toLowerCase()} (${penalty} dice)`,\n          }\n        }),\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedScaleOptions.map(({ value, number, size, area, penalty }) => {\n          return {\n            value: value,\n            label: `${number} subjects, ${area.toLowerCase()} (${penalty} dice)`,\n          }\n        }),\n      })\n      return options\n    },\n    locationYantraOptions() {\n      return this.getYantraOptions(\"l\")\n    },\n    actionYantraOptions() {\n      return this.getYantraOptions(\"a\")\n    },\n    toolYantraOptions() {\n      return this.getYantraOptions(\"t\")\n    },\n    casterSummary() {\n      let summary = []\n      if (this.caster.gnosis > 0) summary.push(`Gnosis ${this.caster.gnosis}`)\n      for (let arcana in this.caster.arcana) {\n        let level = this.caster.arcana[arcana].level\n        if (level > 0) summary.push(`(${arcana} ${dots(level)})`)\n      }\n      return summary.join(\" \")\n    },\n    spellSummary() {\n      let summary = \"\"\n      if (this.spell.name) summary += `${this.spell.name}`\n      if (this.spell.arcana) summary += ` (${this.spell.arcana} ${dots(this.spell.level)})`\n      return summary\n    },\n    methodSummary() {\n      let summary = \"\"\n      if (this.spell.isPraxis) summary += `Praxis`\n      if (this.spell.isRote) summary += `Rote (+${this.spell.roteSkill})`\n      if (this.spell.spendWillpower) {\n        if (this.spell.isPraxis || this.spell.isRote) summary += \" with Willpower\"\n        else summary += \"Willpower\"\n      }\n      return summary\n    },\n    paradoxDiceSummary() {\n      let summary\n\n      if (this.paradoxDice === \"[chance die]\") {\n        summary = \"A chance die\"\n      } else if (this.paradoxDice === 1) {\n        summary = this.paradoxDice + \" die\"\n      } else {\n        summary = this.paradoxDice + \" dice\"\n      }\n\n      if (this.paradox.sleepers) {\n        if (this.paradox.sleeperGroupSize === \"sm\") {\n          summary += \" (with the 9-again quality)\"\n        } else if (this.paradox.sleeperGroupSize === \"md\") {\n          summary += \" (with the 8-again quality)\"\n        } else if (this.paradox.sleeperGroupSize === \"lg\") {\n          summary += \" (with the rote quality)\"\n        }\n      }\n\n      return summary\n    },\n    dicePoolSummary() {\n      if (this.dicePool < 1) {\n        return \"A chance die\"\n      } else if (this.dicePool == 1) {\n        return `${this.dicePool} die`\n      } else {\n        return `${this.dicePool} dice`\n      }\n    },\n    castingTimeSummary() {\n      // standard\n      if (this.spell.factors.castingTime[0] === \"s\") {\n        let increment = this.baseCastingTime.increment * this.spell.factors.castingTime[1],\n          unit = this.baseCastingTime.unit + (increment !== 1 ? \"s\" : \"\")\n\n        return increment + \" \" + unit\n      }\n      // advanced\n      else {\n        let turns = this.numYantras <= 1 ? 1 : this.numYantras\n\n        if (this.hasYantra(\"a3\")) {\n          turns = turns == 1 ? 2 : turns\n        }\n\n        return `${turns} turn${turns !== 1 ? \"s\" : \"\"}`\n      }\n    },\n    durationSummary() {\n      return durations.get(this.spell.factors.duration).time\n    },\n    potencySummary() {\n      return this.potencyValue\n    },\n    rangeSummary() {\n      if (this.spell.factors.range === \"s1\") {\n        return \"Touch/aimed\"\n      } else if (\n        this.spell.attainments.sympatheticRange ||\n        this.spell.attainments.temporalSympathy\n      ) {\n        let range = []\n\n        if (this.spell.attainments.sympatheticRange) {\n          range.push(\"Sympathetic\")\n        }\n\n        if (this.spell.attainments.temporalSympathy) {\n          range.push(\"Temporal Sympathetic\")\n        }\n\n        return range.join(\" and \")\n      } else {\n        return \"Sensory\"\n      }\n    },\n    scaleSummary() {\n      let scale = scales.get(this.spell.factors.scale)\n      return scale ? `${scale.number} subjects or ${scale.area.toLowerCase()}` : \"\"\n    },\n    scalePenalty() {\n      let scale = scales.get(this.spell.factors.scale)\n      return scale ? scale.penalty : \"\"\n    },\n    yantrasSummary() {\n      let yantrasNames = []\n\n      for (let yantra of this.spell.yantras) {\n        yantrasNames.push(this.yantras.get(yantra.yantraKey).name)\n      }\n      if (yantrasNames.length === 0) return \"None\"\n\n      return yantrasNames.join(\", \")\n    },\n    factorCastingTime() {\n      return this.spell.factors.castingTime\n    },\n    factorDuration() {\n      return this.spell.factors.duration\n    },\n    factorRange() {\n      return this.spell.factors.range\n    },\n    factorScale() {\n      return this.spell.factors.scale\n    },\n  },\n  methods: {\n    chooseSpell(spell) {\n      this.spell.name = spell.name\n      this.spell.arcana = spell.arcana\n      this.spell.level = spell.level\n      this.spell.practice = spell.practice\n      this.spell.primaryFactor = spell.primaryFactor\n      this.spell.primaryArcana = spell.primaryArcana\n      this.spell.secondaryArcana = spell.secondaryArcana\n      this.spell.suggestedRoteSkills = spell.suggestedRoteSkills\n      this.spell.description = spell.description\n      this.spell.reachEffects = spell.reachEffects\n      this.spell.source = spell.source\n    },\n    choosePotency(potency) {\n      this.showPotencyModal = false\n      this.spell.factors.potency = potency\n    },\n    chooseDuration(duration) {\n      this.showDurationModal = false\n      this.spell.factors.duration = duration\n    },\n    dots(num) {\n      return Array.from({ length: num }, () => \"•\").join(\"\")\n    },\n    isAdvanced(factorName) {\n      return this.spell.factors[factorName][0] === \"a\"\n    },\n    isPrimaryFactor(factorName) {\n      return this.spell.primaryFactor === factorName\n    },\n    setRote(value) {\n      this.spell.isRote = value\n    },\n    setPraxis(value) {\n      this.spell.isPraxis = value\n    },\n    /**\n     * Called when Caster's Arcana, Potency, Primary Factor or Withstand changed\n     */\n    checkPotencyAgainstWithstand() {\n      let extraPotency = this.spell.factors.potency[1] - 1,\n        prefix = this.spell.factors.potency[0], // 's' or 'a'\n        minPotency = this.subject.isResisted ? this.totalWithstand + 1 : 0,\n        isStandard = prefix !== \"a\"\n\n      // Advanced Potency reduces Withstand by 2\n      if (!isStandard) {\n        minPotency -= 2\n      }\n\n      // is Potency too low?\n      if (extraPotency < minPotency) {\n        // debounce(() => {\n        //   this.spell.factors.potency = prefix + minPotency\n        //   Toast.create(\n        //     `Potency spell factor (${\n        //       prefix === \"s\" ? \"Standard\" : \"Advanced\"\n        //     }) automatically increased to ${minPotency}`\n        //   )\n        // })()\n      }\n    },\n    checkAttainments() {\n      // time in a bottle requires advanced\n      if (this.spell.attainments.timeInABottle && !this.isAdvanced(\"castingTime\")) {\n        // debounce(() => {\n        //   this.spell.attainments.timeInABottle = false\n        //   Toast.create(\n        //     \"Time in a Bottle attainment requires advanced Casting Time. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // permanence requires advanced\n      if (\n        this.spell.attainments.permanence &&\n        (this.spell.arcana !== \"Matter\" || !this.isAdvanced(\"duration\"))\n      ) {\n        // debounce(() => {\n        //   this.spell.attainments.permanence = false\n        //   Toast.create(\n        //     \"Permanence attainment requires advanced Duration. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // everywhere requires advanced\n      if (this.spell.attainments.everywhere && !this.isAdvanced(\"scale\")) {\n        // debounce(() => {\n        //   this.spell.attainments.everywhere = false\n        //   Toast.create(\n        //     \"Everywhere attainment requires advanced Scale. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // sympathy requires advanced\n      if (this.spell.attainments.sympatheticRange && !this.isAdvanced(\"range\")) {\n        // debounce(() => {\n        //   this.spell.attainments.sympatheticRange = false\n        //   Toast.create(\n        //     \"Sympathetic Range attainment requires advanced Range. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // temporal sympathy requires advanced\n      if (this.spell.attainments.temporalSympathy && !this.isAdvanced(\"range\")) {\n        // debounce(() => {\n        //   this.spell.attainments.temporalSympathy = false\n        //   Toast.create(\n        //     \"Temporal Sympathy attainment requires advanced Range. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n    },\n    isUniqueYantraUsed(key) {\n      let yantra = this.yantras.get(key)\n\n      // ignore non-uniques\n      if (!yantra.unique) {\n        return false\n      }\n\n      // this version is used?\n      if (this.hasYantra(key)) {\n        return true\n      }\n\n      // there are multiple version of this yantra - check for others\n      if (key.indexOf(\"_\") !== -1) {\n        let baseKey = key.split(\"_\")[0]\n        if (this.spell.yantras.some((yantra) => yantra.yantraKey.indexOf(baseKey) === 0)) {\n          return true\n        }\n      }\n\n      return false\n    },\n    getYantraOptions(prefix) {\n      let options = []\n\n      for (let [key, yantra] of this.yantras) {\n        if (key[0] === prefix) {\n          // 'l', 'a', or 't'\n          // disabled?\n          let disabledWarning\n\n          if (key === \"a1\" && this.spell.method !== \"Rote\") {\n            disabledWarning = \"Only available when casting Rotes.\"\n          }\n\n          if (key === \"a2\" && !this.isConcentrationMantraAllowed) {\n            disabledWarning = \"Duration must be more than 1 turn to use concentration.\"\n          }\n\n          if (this.isUniqueYantraUsed(key)) {\n            disabledWarning = \"Only one of this Yantra may be used.\"\n          }\n\n          if (key === \"t1\" && this.isDedicatedToolYantraUsed) {\n            disabledWarning = \"A Dedicated Tool is already being used.\"\n          }\n\n          yantra.disabledWarning = disabledWarning\n\n          // add to options\n          options.push(yantra)\n        }\n      }\n\n      return options\n    },\n    hasYantra(key) {\n      return some(this.spell.yantras, [\"yantraKey\", key]) // `_.matchesProperty` iteratee shorthand.\n    },\n    addYantra(key) {\n      let yantra = this.yantras.get(key)\n\n      // check uniques\n      if (this.isUniqueYantraUsed(key)) {\n        // debounce(() => {\n        //   Toast.create(`The ${yantra.name} Yantra can only be selected once`)\n        // })()\n        return\n      }\n\n      this.spell.yantras.push(yantra)\n    },\n    deleteYantra(key) {\n      let index = findIndex(this.spell.yantras, (yantra) => yantra.yantraKey === key)\n      this.spell.yantras.splice(index, 1)\n    },\n    addYantraFromModal(key) {\n      this.addYantra(key)\n\n      this.showYantrasModal = false\n    },\n    updateYantraIsDedicatedTool(key, newValue) {\n      let index = findIndex(this.spell.yantras, (yantra) => yantra.yantraKey === key)\n      this.spell.yantras[index].isDedicatedTool = newValue\n    },\n    log(text) {\n      console.log(text)\n    },\n  },\n  mounted() {\n    useMessage().success(\"Ready to use!\")\n  },\n}\n</script>\n\n<style>\nhtml {\n  height: 100%;\n}\nbody {\n  min-height: 100%;\n}\n.n-layout {\n  min-height: 100vh;\n}\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n.s-table td {\n  vertical-align: middle;\n  line-height: 20px;\n}\n.n-card {\n  box-shadow: var(--n-box-shadow);\n}\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n.n-rate {\n  vertical-align: middle;\n}\n.n-rate__item svg circle {\n  stroke: black;\n}\n.n-rate__item--active svg circle {\n  fill: black;\n  stroke: black;\n}\n.bottom {\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 70px;\n}\n</style>\n"],"names":[],"version":3,"file":"index.e7e625e2.css.map"}