{"mappings":"ACyCA,+BAGA,uFAGA,2DAIA,wFAGA,sKASA,iEC2kDA,iBAGA,iCAIA,8CAGA,uBAGA,+IAKE,yCAIF,8DAKA,kCAGA,iCAGA,0DAKA,mDAIA,gDAIA,yCAGA,uCAGA,sDAIA,8BAGA,oDAGA,qFAOA,yDAOA,2FAIA,2DAKA,yCAEE,2BAGA,+FAIF,0BAGA,sDAGA,wFAMA,kFAOA,sDDltDA,+BAGA,uFAGA,2DAIA,wFAGA,sKASA,iEC2kDA,iBAGA,iCAIA,8CAGA,uBAGA,+IAKE,yCAIF,8DAKA,kCAGA,iCAGA,0DAKA,mDAIA,gDAIA,yCAGA,uCAGA,sDAIA,8BAGA,oDAGA,qFAOA,yDAOA,2FAIA,2DAKA,yCAEE,2BAGA,+FAIF,0BAGA,sDAGA,wFAMA,kFAOA","sources":["index.1cf4b200.css","code/components/Card.vue","code/components/Main.vue"],"sourcesContent":[".card .n-card-header {\n  padding: 0;\n}\n\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content {\n  width: 100px;\n  flex: 1;\n}\n\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content .card-summary {\n  text-align: right;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex: 1;\n  font-size: 85%;\n  line-height: 1.5;\n  overflow: hidden;\n}\n\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n\nhtml {\n  height: 100%;\n}\n\nbody {\n  height: 100%;\n  overflow: hidden;\n}\n\n.n-tabs .n-tabs-pane-wrapper {\n  overflow: visible;\n}\n\n.n-layout {\n  height: 100vh;\n}\n\n@media only screen and (min-device-width: 320px) and (max-device-width: 600px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) {\n  .n-layout {\n    height: -webkit-fill-available;\n  }\n}\n\n.n-tabs {\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 60px 10px 100px;\n}\n\n.n-tabs .n-tabs-tab-pad {\n  width: 5px;\n}\n\n.n-tabs .n-tabs-tab {\n  padding: 10px;\n}\n\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n\n.s-table td {\n  vertical-align: middle;\n  line-height: 20px;\n}\n\n.e-table td {\n  vertical-align: top;\n  line-height: 19px;\n}\n\n.e-table td .n-switch {\n  vertical-align: top;\n}\n\n.n-card {\n  box-shadow: var(--n-box-shadow);\n}\n\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n\n.n-rate {\n  vertical-align: middle;\n}\n\n.n-rate__item svg circle {\n  stroke: var(--n-text-color);\n}\n\n.n-rate__item--active svg circle {\n  fill: var(--n-text-color);\n  stroke: var(--n-text-color);\n}\n\n.quick {\n  z-index: 10;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n  z-index: 10;\n  position: fixed !important;\n}\n\n#spellAffix {\n  width: 100%;\n  max-width: 580px;\n  margin-bottom: -48px;\n}\n\n@media only screen and (max-width: 600px) {\n  #spellAffix {\n    max-width: 100%;\n  }\n\n  #spellAffix.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n    max-width: calc(100% - 20px);\n  }\n}\n\n.spellSummary {\n  height: 45px;\n}\n\n.spellSummary .n-card__content {\n  padding: 10px !important;\n}\n\n.quick .n-card__content {\n  max-width: 600px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px !important;\n}\n\n#spellOptions {\n  width: auto;\n  border-radius: 70px;\n  position: fixed;\n  bottom: 10px;\n  right: 10px;\n}\n\n#spellOptions .n-card__content {\n  padding: 10px !important;\n}\n\n.card .n-card-header {\n  padding: 0;\n}\n\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content {\n  width: 100px;\n  flex: 1;\n}\n\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n\n.card .n-card-header .n-button__content .card-summary {\n  text-align: right;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex: 1;\n  font-size: 85%;\n  line-height: 1.5;\n  overflow: hidden;\n}\n\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n\nhtml {\n  height: 100%;\n}\n\nbody {\n  height: 100%;\n  overflow: hidden;\n}\n\n.n-tabs .n-tabs-pane-wrapper {\n  overflow: visible;\n}\n\n.n-layout {\n  height: 100vh;\n}\n\n@media only screen and (min-device-width: 320px) and (max-device-width: 600px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) {\n  .n-layout {\n    height: -webkit-fill-available;\n  }\n}\n\n.n-tabs {\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 60px 10px 100px;\n}\n\n.n-tabs .n-tabs-tab-pad {\n  width: 5px;\n}\n\n.n-tabs .n-tabs-tab {\n  padding: 10px;\n}\n\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n\n.s-table td {\n  vertical-align: middle;\n  line-height: 20px;\n}\n\n.e-table td {\n  vertical-align: top;\n  line-height: 19px;\n}\n\n.e-table td .n-switch {\n  vertical-align: top;\n}\n\n.n-card {\n  box-shadow: var(--n-box-shadow);\n}\n\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n\n.n-rate {\n  vertical-align: middle;\n}\n\n.n-rate__item svg circle {\n  stroke: var(--n-text-color);\n}\n\n.n-rate__item--active svg circle {\n  fill: var(--n-text-color);\n  stroke: var(--n-text-color);\n}\n\n.quick {\n  z-index: 10;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n  z-index: 10;\n  position: fixed !important;\n}\n\n#spellAffix {\n  width: 100%;\n  max-width: 580px;\n  margin-bottom: -48px;\n}\n\n@media only screen and (max-width: 600px) {\n  #spellAffix {\n    max-width: 100%;\n  }\n\n  #spellAffix.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n    max-width: calc(100% - 20px);\n  }\n}\n\n.spellSummary {\n  height: 45px;\n}\n\n.spellSummary .n-card__content {\n  padding: 10px !important;\n}\n\n.quick .n-card__content {\n  max-width: 600px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px !important;\n}\n\n#spellOptions {\n  width: auto;\n  border-radius: 70px;\n  position: fixed;\n  bottom: 10px;\n  right: 10px;\n}\n\n#spellOptions .n-card__content {\n  padding: 10px !important;\n}\n\n/*# sourceMappingURL=index.1cf4b200.css.map */\n","<template>\n  <n-card size=\"small\" class=\"card\">\n    <template #header>\n      <n-button size=\"large\" text block @click=\"open = !open\">\n        <template #icon>\n          <n-icon>\n            <ChevronUp v-if=\"open == true\" />\n            <ChevronDown v-if=\"open === false\" />\n          </n-icon>\n        </template>\n        <n-text strong class=\"card-title\">{{ title }}</n-text>\n        <n-text depth=\"3\" class=\"card-summary\">{{ summary }}</n-text>\n      </n-button>\n    </template>\n    <template #default v-if=\"open === true\">\n      <slot name=\"content\"></slot>\n    </template>\n    <template #action v-if=\"open === true\">\n      <slot name=\"footer\"></slot>\n    </template>\n  </n-card>\n</template>\n\n<script>\nimport { ChevronDown, ChevronUp } from \"@vicons/ionicons5\"\n\nexport default {\n  components: { ChevronDown, ChevronUp },\n  props: [\"title\", \"summary\", \"collapsed\"],\n  data() {\n    return {\n      open: true,\n    }\n  },\n  mounted() {\n    if (this.collapsed !== undefined) this.open = !!this.collapsed\n  },\n}\n</script>\n\n<style>\n.card .n-card-header {\n  padding: 0;\n}\n.card .n-card-header__main .n-button {\n  padding: var(--n-padding-top) var(--n-padding-left);\n}\n.card .n-card-header .n-button__content {\n  flex: 1;\n  width: 100px;\n}\n.card .n-card-header .n-button__content .card-title {\n  padding-right: var(--n-padding-left);\n}\n.card .n-card-header .n-button__content .card-summary {\n  flex: 1;\n  text-align: right;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 85%;\n  line-height: 1.5;\n}\n.card .n-card__action {\n  border-top: 1px solid var(--n-border-color);\n}\n</style>\n","<template>\n  <n-config-provider :theme=\"theme\" :theme-overrides=\"{ common: { fontWeightStrong: '600' } }\">\n    <n-layout static embedded>\n      <n-tabs default-value=\"spell\" animated>\n        <template #suffix>\n          <!-- <n-button quaternary :disabled=\"canCastSpell === false\" size=\"small\" type=\"warning\" @click=\"reset\"> Reset </n-button> -->\n          <!-- <n-switch v-model:value=\"dark\" @update:value=\"setDark\">\n            <template #checked>Dark</template>\n            <template #unchecked>Dark</template>\n          </n-switch> -->\n        </template>\n        <n-tab-pane name=\"caster\" tab=\"Caster\">\n          <n-space vertical>\n            <!-- Gnosis -->\n            <Card title=\"Gnosis\" :summary=\"gnosisSummary\">\n              <template #content>\n                <n-rate clearable :count=\"10\" v-model:value=\"caster.gnosis\">\n                  <n-icon>\n                    <EllipseOutline />\n                  </n-icon>\n                </n-rate>\n              </template>\n            </Card>\n            <!-- Arcana -->\n            <Card title=\"Arcana\" :summary=\"arcanaSummary\">\n              <template #content>\n                <n-table striped :bordered=\"false\" class=\"s-table\" style=\"margin-left: -8px; width: calc(100% + 16px)\">\n                  <tbody>\n                    <tr v-for=\"(item, name) of caster.arcana\" :key=\"name\">\n                      <td width=\"50\">\n                        <n-text>{{ name }}</n-text>\n                      </td>\n                      <td width=\"20\">\n                        <n-switch size=\"small\" v-model:value=\"item.ruling\" />\n                      </td>\n                      <td>\n                        <n-rate clearable :count=\"5\" v-model:value=\"item.level\">\n                          <n-icon>\n                            <EllipseOutline />\n                          </n-icon>\n                        </n-rate>\n                      </td>\n                    </tr>\n                  </tbody>\n                </n-table>\n              </template>\n            </Card>\n          </n-space>\n        </n-tab-pane>\n        <n-tab-pane name=\"spell\" tab=\"Spell\" :ref=\"container\">\n          <n-space vertical>\n            <!-- Info -->\n            <n-alert type=\"info\" v-if=\"hasConfiguredCaster === false\">\n              <n-text>You need to configure your Gnosis and Arcana in the <b>Caster</b> tab first.</n-text>\n            </n-alert>\n            <n-affix id=\"spellAffix\" v-if=\"hasConfiguredCaster === true\" :trigger-top=\"10\" position=\"absolute\" listen-to=\".n-layout-scroll-container\">\n              <n-card class=\"spellSummary\">\n                <n-space align=\"center\" justify=\"space-between\">\n                  <n-space size=\"small\" v-if=\"canCastSpell\">\n                    <n-tag size=\"small\" :bordered=\"false\" round strong :type=\"usedReach > freeReach ? 'warning' : 'success'\"> Reach {{ usedReach }}/{{ freeReach }} </n-tag>\n                    <n-tag size=\"small\" :bordered=\"false\" round strong :type=\"isDicePoolTooLow ? 'warning' : 'success'\"> Dice Pool {{ dicePool }} </n-tag>\n                    <n-tag size=\"small\" :bordered=\"false\" round strong type=\"success\">Mana {{ totalMana }}</n-tag>\n                    <n-tag v-if=\"hasParadox\" size=\"small\" :bordered=\"false\" round strong type=\"error\"> Paradox {{ paradoxDice }} </n-tag>\n                  </n-space>\n                  <n-space size=\"small\" v-if=\"canCastSpell === false\">\n                    <n-tag size=\"small\" disabled :bordered=\"false\" round strong>Reach 0/0</n-tag>\n                    <n-tag size=\"small\" disabled :bordered=\"false\" round strong>Dice Pool 0</n-tag>\n                    <n-tag size=\"small\" disabled :bordered=\"false\" round strong>Mana 0</n-tag>\n                  </n-space>\n                </n-space>\n              </n-card>\n            </n-affix>\n            <!-- Spell -->\n            <Card title=\"Spell\" :summary=\"spellSummary\" v-if=\"hasConfiguredCaster\" style=\"margin-top: 48px\">\n              <template #content>\n                <n-space vertical size=\"large\">\n                  <n-select filterable placeholder=\"What spell are you casting?\" v-model:value=\"spell.name\" @update:value=\"chooseSpell\" :options=\"chooseSpellOptions\" />\n                  <n-text v-if=\"spell.name\" italic depth=\"2\">{{ spell.description }} ({{ spell.page }})</n-text>\n                  <n-alert type=\"warning\" v-if=\"spell.name && isSpellArcanaTooHigh\">\n                    <n-text>You don't have the arcana required for this spell</n-text>\n                  </n-alert>\n                </n-space>\n              </template>\n              <template #footer>\n                <n-grid v-if=\"spell.name\" :cols=\"4\">\n                  <n-grid-item>\n                    <n-text> <b>Practice</b><br />{{ spell.practice }} </n-text>\n                  </n-grid-item>\n                  <n-grid-item>\n                    <n-text> <b>Factor</b><br />{{ spell.primaryFactor }} </n-text>\n                  </n-grid-item>\n                  <n-grid-item :span=\"2\">\n                    <n-text> <b>Rote Skills</b><br />{{  spell.roteSkills.join(\", \") }}</n-text>\n                  </n-grid-item>\n                </n-grid>\n              </template>\n            </Card>\n            <!-- Effects -->\n            <Card title=\"Effects\" :summary=\"effectsSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-space vertical>\n                  <n-table bordered striped class=\"e-table\" style=\"margin-left: -5px; width: calc(100% + 10px)\">\n                    <tbody>\n                      <tr>\n                        <td width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" v-model:value=\"spell.isPraxis\" @update:value=\"setRote(false)\" />\n                        </td>\n                        <td width=\"150\">\n                          <b>Cast as Praxis</b>\n                        </td>\n                        <td></td>\n                      </tr>\n                      <tr>\n                        <td width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" v-model:value=\"spell.isRote\" @update:value=\"setPraxis(false)\" />\n                        </td>\n                        <td width=\"150\" colspan=\"2\">\n                          <b>Cast as Rote</b>\n                          <b v-if=\"spell.isRote\"> (+{{ spell.roteSkill }} Skill)</b>\n                          <br />\n                          <n-slider v-if=\"spell.isRote\" :tooltip=\"false\" :min=\"0\" :max=\"10\" v-model:value=\"spell.roteSkill\" />\n                        </td>\n                      </tr>\n                      <tr>\n                        <td width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" v-model:value=\"spell.spendWillpower\" />\n                        </td>\n                        <td width=\"150\" colspan=\"2\">\n                          <b>+1 Willpower:</b><br />\n                          Gain +3 dice.\n                        </td>\n                      </tr>\n                      <tr v-for=\"(item, index) of spell.additionalEffects\" :key=\"index\">\n                        <td v-if=\"item.cost\" width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" :disabled=\"isEffectRestricted(item)\" :value=\"isEffectAdded(item)\" @update:value=\"toggleEffect(item)\" />\n                        </td>\n                        <td v-if=\"item.cost\" colspan=\"2\">\n                          <b>{{ item.cost.map(c => `+${c.value} ${c.type}`).join(\", \")}}</b\n                          ><b v-if=\"item.requirement\"> ({{ item.requirement.map(v => `${v.arcana} ${v.value}`).join(\", \") }})</b><b>:</b><br />\n                          {{ item.effect }}\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                </n-space>\n              </template>\n            </Card>\n            <!-- Method -->\n            <Card title=\"Conditions\" collapsed :summary=\"conditionsSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-space vertical size=\"large\">\n                  <n-space vertical size=\"large\">\n                    <n-text strong>Bonus spellcasting dice</n-text>\n                    <n-slider placement=\"right\" :min=\"0\" :max=\"10\" v-model:value=\"conditions.bonusDice\" />\n                  </n-space>\n                  <n-space vertical size=\"large\">\n                    <n-text strong>Spells currently active</n-text>\n                    <n-slider placement=\"right\" :min=\"0\" :max=\"10\" v-model:value=\"conditions.activeSpells\" />\n                  </n-space>\n                  <n-space vertical size=\"large\">\n                    <n-text strong>Withstand rating of subject</n-text>\n                    <n-slider placement=\"right\" :min=\"0\" :max=\"10\" v-model:value=\"conditions.subjectWithstand\" />\n                  </n-space>\n                </n-space>\n              </template>\n              <template #footer v-if=\"conditionsSummary !== 'None'\">\n                <n-space vertical>\n                  <n-text v-if=\"conditions.bonusDice > 0\"><b>Bonus:</b> Can come from Fate magic, Merits, Artefacts, or the Storyteller.</n-text>\n                  <n-text v-if=\"conditions.activeSpells > 0\"><b>Spells:</b> Maintaining more spells than the caster's Gnosis adds Reach.</n-text>\n                  <n-text v-if=\"conditions.subjectWithstand > 0\"><b>Withstand:</b> Potency must exceed this rating for the spell to take effect.</n-text>\n                </n-space>\n              </template>\n            </Card>\n            <!-- Potency -->\n            <Card title=\"Potency\" collapsed :summary=\"potencySummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.potency\" :options=\"potencyOptions\" />\n              </template>\n              <template #footer> Advanced Potency grants an additional -2 to Withstand. </template>\n            </Card>\n            <!-- Duration -->\n            <Card title=\"Duration\" collapsed :summary=\"durationSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.duration\" :options=\"durationOptions\" />\n              </template>\n              <template #footer v-if=\"spell.factors.duration === 'a6'\"> Indefinite duration requires +1 Reach and +1 Mana </template>\n            </Card>\n            <!-- Casting Time -->\n            <Card title=\"Casting Time\" collapsed :summary=\"castingTimeSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.castingTime\" :options=\"castingTimeOptions\" />\n              </template>\n              <template #footer v-if=\"isAdvanced('castingTime')\"> Using more than one Yantra (or High Speech) will increase this time. </template>\n            </Card>\n            <!-- Range -->\n            <Card title=\"Range\" collapsed :summary=\"rangeSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.range\" :options=\"rangeOptions\" />\n              </template>\n            </Card>\n            <!-- Scale -->\n            <Card title=\"Scale\" collapsed :summary=\"scaleSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-select v-model:value=\"spell.factors.scale\" :options=\"scaleOptions\" />\n              </template>\n              <template #footer> Advanced Scale doubles the number of subjects and adds 5 size per additional -2 dice penalty. </template>\n            </Card>\n            <!-- Yantras -->\n            <Card title=\"Yantras\" collapsed :summary=\"yantrasSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-space vertical>\n                  <n-table\n                    v-for=\"(group, name) of {\n                      Locations: locationYantraOptions,\n                      Actions: actionYantraOptions,\n                      Tools: toolYantraOptions,\n                    }\"\n                    :key=\"name\"\n                    striped\n                  >\n                    <thead>\n                      <tr>\n                        <th>{{ name }}</th>\n                        <th width=\"80\"></th>\n                      </tr>\n                    </thead>\n                    <tbody>\n                      <tr v-for=\"yantra in group\" :key=\"yantra.yantraKey\">\n                        <td>\n                          <n-text strong>{{ yantra.name }} (+{{ yantra.bonus }})</n-text><br />\n                          <n-text v-html=\"yantra.desc\" />\n                        </td>\n                        <td v-if=\"hasYantra(yantra.yantraKey) === true\">\n                          <n-button block secondary type=\"error\" @click=\"deleteYantra(yantra.yantraKey)\"> Remove </n-button>\n                        </td>\n                        <td v-if=\"hasYantra(yantra.yantraKey) === false\">\n                          <n-tooltip\n                            :trigger=\"\n                              !!yantra.disabledWarning || numYantras === maxYantras\n                                ? 'hover'\n                                : 'manual'\n                            \"\n                          >\n                            <template #trigger>\n                              <n-button\n                                block\n                                secondary\n                                :type=\"\n                                  !!yantra.disabledWarning || numYantras === maxYantras\n                                    ? 'tertiary'\n                                    : 'success'\n                                \"\n                                @click=\"\n                                  !yantra.disabledWarning && numYantras < maxYantras\n                                    ? addYantra(yantra.yantraKey)\n                                    : undefined\n                                \"\n                              >\n                                Add\n                              </n-button>\n                            </template>\n                            <span v-if=\"numYantras === maxYantras\"> You cannot have more than {{ maxYantras }} yantras </span>\n                            <span v-if=\"numYantras !== maxYantras\">\n                              {{ yantra.disabledWarning }}\n                            </span>\n                          </n-tooltip>\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                </n-space>\n              </template>\n              <template #footer> Gnosis {{ caster.gnosis }} allows the use of {{ maxYantras }} yantras. </template>\n            </Card>\n            <!-- Paradox -->\n            <Card title=\"Paradox\" collapsed :summary=\"paradoxSummary\" v-if=\"canCastSpell\">\n              <template #content>\n                <n-space vertical>\n                  <n-table bordered striped class=\"e-table\" style=\"margin-left: -5px; width: calc(100% + 10px)\">\n                    <tbody>\n                      <tr>\n                        <td width=\"20\" style=\"padding-right: 0\">\n                          <n-switch size=\"small\" v-model:value=\"paradox.inured\" />\n                        </td>\n                        <td colspan=\"2\">\n                          <b>Mage is inured?</b>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td colspan=\"3\">\n                          <n-space vertical>\n                            <b>Previous paradox rolls? ({{paradox.previous}})</b>\n                            <n-slider placement=\"bottom\" v-model:value=\"paradox.previous\" :min=\"0\" :max=\"10\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td colspan=\"3\">\n                          <n-space vertical>\n                            <b>Sleeper witnesses? ({{ ['None', 'One', 'Some', 'Many', 'Crowd'][paradox.sleepers] }})</b>\n                            <n-slider placement=\"bottom\" v-model:value=\"paradox.sleepers\" :min=\"0\" :max=\"4\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td colspan=\"3\">\n                          <n-space vertical>\n                            <b>Mana spent? ({{ paradox.manaSpent }})</b>\n                            <n-slider placement=\"bottom\" v-model:value=\"paradox.manaSpent\" :min=\"0\" :max=\"caster.gnosis\" />\n                          </n-space>\n                        </td>\n                      </tr>\n                    </tbody>\n                  </n-table>\n                </n-space>\n              </template>\n              <template #footer> Advanced Scale doubles the number of subjects and adds 5 size per additional -2 dice penalty. </template>\n            </Card>\n          </n-space>\n          <n-card id=\"spellOptions\">\n            <n-space size=\"small\">\n              <n-button quaternary :disabled=\"canCastSpell === false\" size=\"small\" type=\"warning\" @click=\"reset\"> Reset </n-button>\n              <n-button round :disabled=\"canCastSpell === false\" size=\"small\" type=\"info\" @click=\"copyActiveSpell()\">Roll20</n-button>\n              <n-button round :disabled=\"canCastSpell === false\" size=\"small\" type=\"success\" @click=\"saveActiveSpell()\">Save</n-button>\n            </n-space>\n          </n-card>\n        </n-tab-pane>\n        <n-tab-pane name=\"saved\" :tab=\"`Saved (${saved.length})`\">\n          <n-space vertical>\n            <n-card embedded v-if=\"saved.length === 0\">\n              <n-text italic depth=\"3\">No saved spells found</n-text>\n            </n-card>\n            <!-- Saved -->\n            <Card :title=\"item.name\" collapsed :summary=\"item.castingSummary\" v-for=\"(item, index) in saved\" :key=\"index\">\n              <template #content>\n                <n-space vertical>\n                  <n-text><b>Casting:</b> {{ item.castingSummary }}.</n-text>\n                  <n-text><b>Factors:</b> {{ item.factorSummary }}.</n-text>\n                  <n-text v-if=\"item.effectSummary\"><b>Effects:</b> {{ item.effectSummary }}</n-text>\n                  <n-text v-if=\"item.yantraSummary\"><b>Yantras:</b> {{ item.yantraSummary }}.</n-text>\n                </n-space>\n              </template>\n              <template #footer>\n                <n-space justify=\"space-between\">\n                  <n-button quaternary size=\"small\" type=\"error\" @click=\"removeSpell(item)\"> Remove </n-button>\n                  <n-space>\n                    <n-button size=\"small\" type=\"info\" @click=\"copySavedSpell(item)\">Roll20</n-button>\n                    <n-button size=\"small\" type=\"success\" @click=\"loadSpell(item)\">Load</n-button>\n                  </n-space>\n                </n-space>\n              </template>\n            </Card>\n          </n-space>\n        </n-tab-pane>\n      </n-tabs>\n    </n-layout>\n  </n-config-provider>\n</template>\n\n<script>\nimport { ref } from \"vue\"\nimport { clone, max, some, capitalize, findIndex, range } from \"lodash\"\nimport { useMessage } from \"naive-ui\"\nimport { darkTheme, lightTheme } from \"naive-ui\"\n\nimport { Close, Save, Reload, ChevronDown, ChevronUp, Ellipse, EllipseOutline } from \"@vicons/ionicons5\"\n\nimport Card from \"./Card.vue\"\n\nimport {\n  arcanaNames,\n  baseCastingTimes,\n  castingMethods,\n  factors,\n  gnosisManaLimits,\n  durations,\n  scales,\n  yantrasBaseData,\n} from \"../constants/constants.js\"\nimport { spells } from \"../constants/spells.js\"\n\nfunction dots(num) {\n  return Array.from({ length: num }, () => \"â€¢\").join(\"\")\n}\n\nconst defaultCaster = {\n  gnosis: 0,\n  arcana: {\n    Death: { level: 0, ruling: false },\n    Fate: { level: 0, ruling: false },\n    Forces: { level: 0, ruling: false },\n    Life: { level: 0, ruling: false },\n    Matter: { level: 0, ruling: false },\n    Mind: { level: 0, ruling: false },\n    Prime: { level: 0, ruling: false },\n    Spirit: { level: 0, ruling: false },\n    Space: { level: 0, ruling: false },\n    Time: { level: 0, ruling: false },\n  },\n}\nconst defaultSpell = {\n  name: undefined,\n  isRote: false,\n  isPraxis: false,\n  practice: undefined,\n  primaryFactor: undefined,\n  primaryArcana: undefined,\n  secondaryArcana: undefined,\n  description: undefined,\n  effects: [],\n  additionalEffects: [],\n  description: undefined,\n  page: undefined,\n  factors: {\n    castingTime: \"s1\",\n    potency: \"s1\",\n    range: \"s1\",\n    duration: \"s1\",\n    scale: \"s1\",\n  },\n  roteSkills: [],\n  roteSkill: 0,\n  spendWillpower: false,\n  extraReach: 0,\n  yantras: [],\n  yantraAlsoDedicatedTool: null,\n  attainments: {\n    conditionalDuration: false,\n    everywhere: false,\n    permanence: false,\n    sympatheticRange: false,\n    temporalSympathy: false,\n    timeInABottle: false,\n  },\n}\nconst defaultConditions = {\n  subjectWithstand: 0,\n  activeSpells: 0,\n  bonusDice: 0,\n}\nconst defaultParadox = {\n  inured: false,\n  previous: 0,\n  sleepers: 0,\n  manaSpent: 0,\n}\n\nexport default {\n  components: { Card, Save, Reload, Close, ChevronDown, ChevronUp, Ellipse, EllipseOutline },\n  setup() {\n    const message = useMessage()\n    const container = ref(undefined)\n    return {\n      darkTheme,\n      lightTheme,\n      container: container,\n      message: message,\n      // theme: lightTheme,\n    }\n  },\n  data() {\n    return {\n      caster: clone(defaultCaster),\n      spell: clone(defaultSpell),\n      conditions: clone(defaultConditions),\n      paradox: clone(defaultParadox),\n      saved: [],\n      theme: lightTheme,\n      dark: false,\n    }\n  },\n  computed: {\n    hasConfiguredCaster() {\n      return this.caster.gnosis > 0 && this.highestCasterArcana.length > 0\n    },\n    canCastSpell() {\n      if (this.spell.name === undefined) return false\n      if (this.isSpellArcanaTooHigh === true) return false\n      return true\n    },\n    chooseSpellLabel() {\n      return this.spell.name\n    },\n    chooseSpellOptions() {\n      let options = []\n\n      for (let arcanaName of arcanaNames) {\n        options.push({\n          type: \"group\",\n          label: arcanaName,\n          key: arcanaName,\n          children: spells\n            .filter((s) => s.primaryArcana.arcana === arcanaName)\n            .sort((a, b) => a.primaryArcana.level - b.primaryArcana.level)\n            .map((s) => {\n              return {\n                label: `${dots(s.primaryArcana.level)} ${s.name}`,\n                value: s,\n              }\n            }),\n        })\n      }\n\n      return options\n    },\n    methodOptions() {\n      let options = []\n\n      for (let method of castingMethods) {\n        options.push({\n          label: method,\n          value: method,\n        })\n      }\n\n      return options\n    },\n    arcanaNameOptions() {\n      let options = []\n\n      for (let arcanaName of arcanaNames) {\n        options.push({\n          label: arcanaName,\n          value: arcanaName,\n        })\n      }\n\n      return options\n    },\n    highestCasterArcana() {\n      let highest = max(Object.values(this.caster.arcana).map((a) => a.level))\n      let arcanas = []\n      if (highest === 0) return arcanas\n      for (let arcana in this.caster.arcana) {\n        if (this.caster.arcana[arcana].level === highest) arcanas.push(arcana)\n      }\n      return arcanas\n    },\n    maxCasterArcana() {\n      let arcana\n\n      if (this.highestCasterArcana.includes(this.spell.primaryArcana.arcana)) {\n        if (this.caster.gnosis >= 5) {\n          arcana = 5\n        } else if (this.caster.gnosis >= 3) {\n          arcana = 4\n        } else {\n          arcana = 3\n        }\n      } else {\n        if (this.caster.gnosis >= 6) {\n          arcana = 5\n        } else if (this.caster.gnosis >= 4) {\n          arcana = 4\n        } else {\n          arcana = 3\n        }\n      }\n\n      return arcana\n    },\n    isCasterArcanaTooHigh() {\n      return this.caster.arcana[this.spell.primaryArcana.arcana].level > this.maxCasterArcana\n    },\n    isSpellArcanaTooHigh() {\n      if (this.spell.primaryArcana && this.caster.arcana[this.spell.primaryArcana.arcana].level < this.spell.primaryArcana.level) return true\n      if (this.spell.secondaryArcana && this.caster.arcana[this.spell.secondaryArcana.arcana].level < this.spell.secondaryArcana.level) return true\n      return false\n    },\n    freeReach() {\n      let arcana\n\n      if (this.spell.isRote) {\n        arcana = 5\n      } else {\n        arcana = this.caster.arcana[this.spell.primaryArcana.arcana].level\n      }\n\n      return arcana - this.spell.primaryArcana.level + 1\n    },\n    usedReach() {\n      let reach = 0\n\n      if (this.conditions.activeSpells >= this.caster.gnosis) {\n        reach += this.conditions.activeSpells - this.caster.gnosis + 1\n      }\n\n      // check factors (advanced factor keys begin with \"a\")\n      for (let factor of factors) {\n        if (this.spell.factors[factor][0] === \"a\") {\n          reach++\n        }\n      }\n\n      // check effects\n      for (let effect of this.spell.effects) {\n        if (effect.cost) {\n          for (let cost of effect.cost) {\n            if (cost.type === \"Reach\") reach += cost.value\n          }\n        }\n      }\n\n      // indefinite duration costs 1 reach\n      if (!this.isPrimaryFactor(\"Duration\") && this.spell.factors.duration === \"a6\") {\n        reach++\n      }\n\n      // spell-specific extra reach\n      reach += this.spell.extraReach\n\n      if (this.spell.attainments.permanence) {\n        reach--\n      }\n\n      if (this.spell.attainments.timeInABottle) {\n        reach--\n      }\n\n      if (this.spell.attainments.everywhere) {\n        reach--\n      }\n\n      return reach\n    },\n    roteOrPraxis() {\n      if (this.spell.isRote) {\n        return \"rote\"\n      } else if (this.spell.isPraxis) {\n        return \"praxis\"\n      } else {\n        return null\n      }\n    },\n    baseParadoxDice() {\n      return Math.ceil(this.caster.gnosis / 2)\n    },\n    paradoxDice() {\n      let pool, mustRoll\n\n      pool = 0\n      mustRoll = false\n\n      if (this.usedReach > this.freeReach) {\n        pool += (this.freeReach - this.usedReach) * -1\n        mustRoll = true\n      }\n\n      // gnosis multiplies paradox from additional reach\n      pool *= this.baseParadoxDice\n\n      if (this.paradox.inured) {\n        pool += 2\n        mustRoll = true\n      }\n\n      if (this.paradox.previous > 0) {\n        pool += this.paradox.previous\n        mustRoll = true\n      }\n\n      if (this.paradox.sleepers > 0) {\n        pool++\n        mustRoll = true\n      }\n\n      if (this.isDedicatedToolYantraUsed) {\n        pool -= 2\n      }\n\n      pool -= this.paradox.manaSpent\n\n      if (pool <= 0 && mustRoll) {\n        return \"[chance die]\"\n      }\n\n      return pool\n    },\n    hasParadox() {\n      return (\n        this.usedReach > this.freeReach ||\n        this.paradox.inured ||\n        this.paradox.previous > 0 ||\n        this.paradox.sleepers > 0\n      )\n    },\n    durationPenalty() {\n      let penalty = durations.get(this.spell.factors.duration).penalty\n\n      if (this.isPrimaryFactor(\"Duration\")) {\n        penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n      }\n\n      if (penalty <= 0) {\n        penalty = 0\n      }\n\n      return penalty\n    },\n    potencyValue() {\n      return this.spell.factors.potency.substr(1)\n    },\n    potencyPenalty() {\n      let penalty = (this.potencyValue - 1) * 2\n\n      if (this.isPrimaryFactor(\"Potency\")) {\n        penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n      }\n\n      if (penalty <= 0) {\n        penalty = 0\n      }\n\n      return penalty\n    },\n    dicePool() {\n      // base pool\n      let pool = this.caster.gnosis + this.caster.arcana[this.spell.primaryArcana.arcana].level\n\n      pool += this.conditions.bonusDice\n\n      if (this.spell.spendWillpower) {\n        pool += 3\n      }\n\n      // casting time\n      if (!this.isAdvanced(\"castingTime\")) {\n        pool += this.spell.factors.castingTime[1] - 1\n      }\n\n      // withstand\n      pool -= this.totalWithstand\n\n      // potency\n      pool -= this.potencyPenalty\n\n      // duration\n      pool -= this.durationPenalty\n\n      // scale\n      pool -= scales.get(this.spell.factors.scale).penalty\n\n      // yantras\n      this.spell.yantras.forEach((yantra) => {\n        pool += yantra.bonus\n      })\n\n      return pool\n    },\n    isDicePoolTooLow() {\n      return this.dicePool < 1\n    },\n    spellFactorOptions() {\n      return [\n        {\n          label: \"Duration\",\n          value: \"Duration\",\n        },\n        {\n          label: \"Potency\",\n          value: \"Potency\",\n        },\n      ]\n    },\n    primaryFactor() {\n      return this.spell.primaryFactor\n    },\n    primaryFactorLabel() {\n      return capitalize(this.spell.primaryFactor)\n    },\n    totalWithstand() {\n\n      let withstand = this.conditions.subjectWithstand\n\n      if (this.spell.factors.potency === \"a1\") {\n        withstand -= 2\n      }\n\n      return withstand\n    },\n    yantras() {\n      let expandedYantras = new Map()\n\n      for (let [key, yantraBaseData] of yantrasBaseData) {\n        // bonus can contain a single number or a range. Arrayify.\n        let bonuses\n        if (Array.isArray(yantraBaseData.bonus)) {\n          bonuses = range(yantraBaseData.bonus[0], yantraBaseData.bonus[1] + 1)\n        } else {\n          bonuses = [yantraBaseData.bonus]\n        }\n\n        bonuses.forEach((bonus) => {\n          let expandedYantra = clone(yantraBaseData)\n\n          /*\n           * Bonus\n           */\n\n          // rote skill mudra: bonus = skill dots\n          if (key === \"a1\" && this.spell.isRote) {\n            bonus = this.spell.roteSkill\n          }\n\n          // sympathetic yantras don't give a bonus to sympathetic or temporal spells\n          if (\n            [\"t4\", \"t5\"].includes(key) &&\n            (this.spell.attainments.sympatheticRange || this.spell.attainments.temporalSympathy)\n          ) {\n            bonus = 0\n          }\n\n          expandedYantra.yantraKey = Array.isArray(yantraBaseData.bonus) ? key + \"_\" + bonus : key // key is a reserved property in Vue so we use \"yantraKey\"\n          expandedYantra.bonus = bonus\n          expandedYantra.label = `${yantraBaseData.name} (+${bonus} ${\n            bonus === 1 ? \"die\" : \"dice\"\n          })`\n          expandedYantra.isDedicatedTool = false\n          expandedYantras.set(expandedYantra.yantraKey, expandedYantra)\n        })\n      }\n\n      return expandedYantras\n    },\n    maxYantras() {\n      return Math.ceil(this.caster.gnosis / 2) + 1\n    },\n    numYantras() {\n      return this.spell.yantras.length\n    },\n    isConcentrationMantraAllowed() {\n      return this.isPrimaryFactor(\"Duration\") || this.spell.factors.duration !== \"s1\"\n    },\n    isDedicatedToolYantraUsed: {\n      cache: false,\n      // getter\n      get() {\n        if (this.hasYantra(\"t1\")) {\n          return true\n        }\n\n        return some(this.spell.yantras, [\"isDedicatedTool\", true])\n      },\n      // setter (bool)\n      set(isUsed) {\n        if (isUsed) {\n          if (this.isDedicatedToolYantraUsed) {\n            // debounce(() => {\n            //   Toast.create(\"A Dedicated Tool is already selected\")\n            // })()\n          }\n\n          this.spell.yantras.push(this.yantras.get(\"t1\"))\n        } else {\n          this.deleteYantra(\"t1\")\n\n          for (let key of this.spell.yantras) {\n            this.spell.yantras[key].isDedicatedTool = false\n          }\n\n          this.$forceUpdate() // cache: false and this.$forceUpdate() means the getter shows updated value\n        }\n      },\n    },\n    totalMana() {\n      let mana = 0\n\n      if (\n        !this.caster.arcana[this.spell.primaryArcana.arcana].ruling &&\n        !this.spell.isRote &&\n        !this.spell.isPraxis\n      ) {\n        mana++\n      }\n\n      // check effects\n      for (let effect of this.spell.effects) {\n        if (effect.cost) {\n          for (let cost of effect.cost) {\n            if (cost.type === \"Mana\") mana += cost.value\n          }\n        }\n      }\n\n      if (this.spell.factors.duration === \"a6\") {\n        mana++\n      }\n\n      if (this.spell.attainments.permanence) {\n        mana++\n      }\n\n      if (this.spell.attainments.timeInABottle) {\n        mana++\n      }\n\n      if (this.spell.attainments.sympatheticRange) {\n        mana++\n      }\n\n      if (this.spell.attainments.temporalSympathy) {\n        mana++\n      }\n\n      if (this.spell.attainments.everywhere) {\n        mana++\n      }\n\n      mana += this.paradox.manaSpent\n\n      return mana\n    },\n    maxMana() {\n      return gnosisManaLimits[this.caster.gnosis]\n    },\n    // use this to watch attainments changing\n    attainmentsByName() {\n      let attainments = []\n\n      each(this.spell.attainments, (value, key) => {\n        if (value) {\n          attainments.push(key)\n        }\n      })\n\n      return attainments\n    },\n    isSympatheticYantraMissing() {\n      return (\n        (this.spell.attainments.sympatheticRange || this.spell.attainments.temporalSympathy) &&\n        !this.hasYantra(\"t3\") &&\n        !this.hasYantra(\"t4\") &&\n        !this.hasYantra(\"t5\")\n      )\n    },\n    isCastable() {\n      return !this.isDicePoolTooLow && !this.isSympatheticYantraMissing\n    },\n    baseCastingTime() {\n      for (let [key, value] of baseCastingTimes) {\n        if (this.caster.gnosis >= key) {\n          return value\n        }\n      }\n      return null\n    },\n    standardCastingTimeOptions() {\n      let options = [],\n        i = 0\n\n      while (i++ <= 5) {\n        let increment = this.baseCastingTime.increment * i,\n          unit = this.baseCastingTime.unit + (increment !== 1 ? \"s\" : \"\"),\n          bonus = i - 1\n\n        options.push({\n          value: \"s\" + i,\n          label: `${increment} ${unit} (+${bonus} dice)`,\n        })\n      }\n\n      return options\n    },\n    castingTimeOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard (Ritual Casting)\",\n        key: \"standard\",\n        children: this.standardCastingTimeOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced (Quick Casting)\",\n        key: \"advanced\",\n        children: [{ value: \"a1\", label: \"1 Turn\" }],\n      })\n      return options\n    },\n    standardPotencyOptions() {\n      let options = [],\n        i = 0\n\n      while (i++ < 11) {\n        let penalty = (i - 1) * 2\n\n        if (this.isPrimaryFactor(\"Potency\")) {\n          penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n        }\n\n        if (penalty < 0) {\n          penalty = 0\n        }\n\n        options.push({\n          value: \"s\" + i,\n          label: `${i} (-${penalty} dice)`,\n        })\n      }\n\n      return options\n    },\n    advancedPotencyOptions() {\n      let options = []\n      let i = 0\n      while (i++ < 11) {\n        let penalty = (i - 1) * 2\n\n        if (this.isPrimaryFactor(\"Potency\")) {\n          penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n        }\n\n        if (penalty < 0) {\n          penalty = 0\n        }\n\n        options.push({\n          value: \"a\" + i,\n          label: `${i} (-${penalty} dice)`,\n        })\n      }\n\n      return options\n    },\n    potencyOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardPotencyOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedPotencyOptions,\n      })\n      return options\n    },\n    rangeOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: [{ value: \"s1\", label: \"Touch/Aimed\" }],\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: [{ value: \"a1\", label: \"Sensory\" }],\n      })\n      return options\n    },\n    standardDurationOptions() {\n      let options = []\n\n      for (let [key, duration] of durations) {\n        if (key[0] === \"s\") {\n          let penalty = duration.penalty\n\n          if (this.isPrimaryFactor(\"Duration\")) {\n            penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n          }\n\n          if (penalty < 0) {\n            penalty = 0\n          }\n\n          options.push({\n            value: key,\n            successes: key[1],\n            time: duration.time,\n            label: `${duration.time} (-${penalty} dice)`,\n          })\n        }\n      }\n\n      return options\n    },\n    advancedDurationOptions() {\n      let options = []\n\n      for (let [key, duration] of durations) {\n        if (key[0] === \"a\") {\n          let penalty = duration.penalty\n\n          if (this.isPrimaryFactor(\"Duration\")) {\n            penalty -= (this.caster.arcana[this.spell.primaryArcana.arcana].level - 1) * 2\n          }\n\n          if (penalty < 0) {\n            penalty = 0\n          }\n\n          options.push({\n            value: key,\n            successes: key[1],\n            time: duration.time,\n            label: `${duration.time} (-${penalty} dice)`,\n          })\n        }\n      }\n\n      return options\n    },\n    durationOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardDurationOptions,\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedDurationOptions,\n      })\n      return options\n    },\n    standardScaleOptions() {\n      let options = []\n\n      for (let [key, scale] of scales) {\n        if (key[0] === \"s\") {\n          let s = clone(scale)\n          s.value = key\n          s.penalty = `-${scale.penalty}`\n          options.push(s)\n        }\n      }\n\n      return options\n    },\n    advancedScaleOptions() {\n      let options = []\n\n      for (let [key, scale] of scales) {\n        if (key[0] === \"a\") {\n          let s = clone(scale)\n          s.value = key\n          s.penalty = `-${scale.penalty}`\n          options.push(s)\n        }\n      }\n\n      return options\n    },\n    scaleOptions() {\n      let options = []\n      options.push({\n        type: \"group\",\n        label: \"Standard\",\n        key: \"standard\",\n        children: this.standardScaleOptions.map(({ value, number, size, area, penalty }) => {\n          return {\n            value: value,\n            label: `${number} subjects or ${area.toLowerCase()} (${penalty} dice)`,\n          }\n        }),\n      })\n      options.push({\n        type: \"group\",\n        label: \"Advanced\",\n        key: \"advanced\",\n        children: this.advancedScaleOptions.map(({ value, number, size, area, penalty }) => {\n          return {\n            value: value,\n            label: `${number} subjects or ${area.toLowerCase()} (${penalty} dice)`,\n          }\n        }),\n      })\n      return options\n    },\n    locationYantraOptions() {\n      return this.getYantraOptions(\"l\")\n    },\n    actionYantraOptions() {\n      return this.getYantraOptions(\"a\")\n    },\n    toolYantraOptions() {\n      return this.getYantraOptions(\"t\")\n    },\n    gnosisSummary() {\n      let summary = \"\"\n      if (this.caster.gnosis > 0) summary += `Gnosis ${this.caster.gnosis}`\n      if (summary.length === 0) return \"None\"\n      return summary\n    },\n    arcanaSummary() {\n      let summary = []\n      for (let arcana in this.caster.arcana) {\n        let level = this.caster.arcana[arcana].level\n        if (level > 0) summary.push(`${arcana} ${level}`)\n      }\n      if (summary.length === 0) return \"None\"\n      return summary.join(\", \")\n    },\n    effectsSummary() {\n      let summary = []\n      if (this.spell.isPraxis) summary.push(`Praxis`)\n      if (this.spell.isRote) summary.push(`Rote (+${this.spell.roteSkill})`)\n      if (this.spell.effects.length || this.spell.spendWillpower) summary.push(`Effects (${this.spell.effects.length + (this.spell.spendWillpower ? 1 : 0)})`)\n      if (summary.length === 0) return \"None\"\n      return summary.join(\", \")\n    },\n    conditionsSummary() {\n      let summary = []\n      if (this.conditions.bonusDice > 0) summary.push(`+${this.conditions.bonusDice} dice`)\n      if (this.conditions.activeSpells > 0) summary.push(`${this.conditions.activeSpells} active`)\n      if (this.conditions.subjectWithstand > 0) summary.push(`${this.conditions.subjectWithstand} withstand`)\n      if (summary.length === 0) return \"None\"\n      return summary.join(\", \")\n    },\n    spellSummary() {\n      let summary = \"\"\n      if (this.spell.name) summary += `${this.spell.name} (`\n      if (this.spell.primaryArcana?.arcana) summary += `${this.spell.primaryArcana.arcana} ${this.spell.primaryArcana.level}`\n      if (this.spell.secondaryArcana?.arcana) summary += `, ${this.spell.secondaryArcana.arcana} ${this.spell.secondaryArcana.level}`\n      if (this.spell.name) summary += \")\"\n      if (summary.length === 0) return \"None\"\n      return summary\n    },\n    paradoxDiceSummary() {\n      let summary\n\n      if (this.paradoxDice === \"[chance die]\") {\n        summary = \"A chance die\"\n      } else if (this.paradoxDice === 1) {\n        summary = this.paradoxDice + \" die\"\n      } else {\n        summary = this.paradoxDice + \" dice\"\n      }\n\n      if (this.paradox.sleepers > 0) {\n        if (this.paradox.sleepers === 2) {\n          summary += \" (with the 9-again quality)\"\n        } else if (this.paradox.sleepers === 3) {\n          summary += \" (with the 8-again quality)\"\n        } else if (this.paradox.sleepers === 4) {\n          summary += \" (with the rote quality)\"\n        }\n      }\n\n      return summary\n    },\n    dicePoolSummary() {\n      if (this.dicePool < 1) {\n        return \"A chance die\"\n      } else if (this.dicePool == 1) {\n        return `${this.dicePool} die`\n      } else {\n        return `${this.dicePool} dice`\n      }\n    },\n    castingTimeSummary() {\n      // standard\n      if (this.spell.factors.castingTime[0] === \"s\") {\n        let increment = this.baseCastingTime.increment * this.spell.factors.castingTime[1],\n          unit = this.baseCastingTime.unit + (increment !== 1 ? \"s\" : \"\")\n\n        return increment + \" \" + unit\n      }\n      // advanced\n      else {\n        let turns = this.numYantras <= 1 ? 1 : this.numYantras\n\n        if (this.hasYantra(\"a3\")) {\n          turns = turns == 1 ? 2 : turns\n        }\n\n        return `${turns} turn${turns !== 1 ? \"s\" : \"\"}`\n      }\n    },\n    durationSummary() {\n      return durations.get(this.spell.factors.duration).time\n    },\n    potencySummary() {\n      return this.potencyValue\n    },\n    rangeSummary() {\n      if (this.spell.factors.range === \"s1\") {\n        return \"Touch/aimed\"\n      } else if (\n        this.spell.attainments.sympatheticRange ||\n        this.spell.attainments.temporalSympathy\n      ) {\n        let range = []\n\n        if (this.spell.attainments.sympatheticRange) {\n          range.push(\"Sympathetic\")\n        }\n\n        if (this.spell.attainments.temporalSympathy) {\n          range.push(\"Temporal Sympathetic\")\n        }\n\n        return range.join(\" and \")\n      } else {\n        return \"Sensory\"\n      }\n    },\n    scaleSummary() {\n      let scale = scales.get(this.spell.factors.scale)\n      return scale ? `${scale.number} subjects or ${scale.area.toLowerCase()}` : \"\"\n    },\n    scalePenalty() {\n      let scale = scales.get(this.spell.factors.scale)\n      return scale ? scale.penalty : \"\"\n    },\n    paradoxSummary() {\n      return this.paradoxDiceSummary\n    },\n    yantrasSummary() {\n      let yantrasNames = []\n\n      for (let yantra of this.spell.yantras) {\n        yantrasNames.push(this.yantras.get(yantra.yantraKey).name)\n      }\n      if (yantrasNames.length === 0) return \"None\"\n\n      return yantrasNames.join(\", \")\n    },\n    factorCastingTime() {\n      return this.spell.factors.castingTime\n    },\n    factorDuration() {\n      return this.spell.factors.duration\n    },\n    factorRange() {\n      return this.spell.factors.range\n    },\n    factorScale() {\n      return this.spell.factors.scale\n    },\n  },\n  watch: {\n    caster: {\n      handler(value) {\n        localStorage.setItem(\"caster\", JSON.stringify(value))\n      },\n      deep: true,\n    },\n    saved: {\n      handler(value) {\n        localStorage.setItem(\"saved\", JSON.stringify(value))\n      },\n      deep: true,\n    },\n    dark: {\n      handler(value) {\n        console.log('dark changed', value)\n        localStorage.setItem(\"dark\", JSON.stringify(value))\n      },\n    },\n    \"spell.isRote\": function (newer, older) {\n      if (older === true && newer === false && this.hasYantra(\"a1\")) {\n        this.deleteYantra(\"a1\")\n        this.message.warning(\"Rote Skill Mudra removed from yantras\")\n      }\n        // if (this.hasYantra(\"a1\") && spell.isRote === true) {\n        //   setTimeout(() => {\n        //     let yantra = spell.yantras.findIndex((y) => y.yantraKey === \"a1\")\n        //     if (yantra.bonus !== spell.roteSkill) {\n        //       this.message.info(\"Rote Skill Mudra updated to +\" + spell.roteSkill)\n        //       spell.yantras[yantra].bonus = spell.roteSkill\n        //     }\n        //   }, 250)\n        // }\n    },\n    \"conditions.subjectWithstand\": function (newer, older) {\n      let extraPotency = this.spell.factors.potency[1] - 1\n      let prefix = this.spell.factors.potency[0]\n      let minPotency = this.totalWithstand\n      let isStandard = prefix !== \"a\"\n\n      // Advanced Potency reduces Withstand by 2\n      if (!isStandard) minPotency -= 2\n\n      // Potency too low?\n      if (extraPotency < minPotency) {\n        this.spell.factors.potency = prefix + minPotency\n        this.message.info(`Potency (${prefix === \"s\" ? \"Standard\" : \"Advanced\"}) increased to ${minPotency}`)\n      }\n    },\n  },\n  methods: {\n    setDark(value) {\n      if (value === true) this.theme = darkTheme\n      if (value === false) this.theme = lightTheme\n    },\n    chooseSpell(spell) {\n      this.spell.name = spell.name\n      this.spell.practice = spell.practice\n      this.spell.primaryArcana = spell.primaryArcana\n      this.spell.secondaryArcana = spell.secondaryArcana\n      this.spell.primaryFactor = spell.primaryFactor\n      this.spell.roteSkills = spell.roteSkills\n      this.spell.description = spell.description\n      this.spell.additionalEffects = spell.additionalEffects\n      this.spell.effects = []\n      this.spell.yantras = []\n      this.spell.page = spell.page\n    },\n    dots(num) {\n      return Array.from({ length: num }, () => \"â€¢\").join(\"\")\n    },\n    isAdvanced(factorName) {\n      return this.spell.factors[factorName][0] === \"a\"\n    },\n    isPrimaryFactor(factorName) {\n      return this.spell.primaryFactor === factorName\n    },\n    setRote(value) {\n      this.spell.isRote = value\n    },\n    setPraxis(value) {\n      this.spell.isPraxis = value\n    },\n    checkAttainments() {\n      // time in a bottle requires advanced\n      if (this.spell.attainments.timeInABottle && !this.isAdvanced(\"castingTime\")) {\n        // debounce(() => {\n        //   this.spell.attainments.timeInABottle = false\n        //   Toast.create(\n        //     \"Time in a Bottle attainment requires advanced Casting Time. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // permanence requires advanced\n      if (\n        this.spell.attainments.permanence &&\n        (this.spell.primaryArcana.arcana !== \"Matter\" || !this.isAdvanced(\"Duration\"))\n      ) {\n        // debounce(() => {\n        //   this.spell.attainments.permanence = false\n        //   Toast.create(\n        //     \"Permanence attainment requires advanced Duration. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // everywhere requires advanced\n      if (this.spell.attainments.everywhere && !this.isAdvanced(\"scale\")) {\n        // debounce(() => {\n        //   this.spell.attainments.everywhere = false\n        //   Toast.create(\n        //     \"Everywhere attainment requires advanced Scale. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // sympathy requires advanced\n      if (this.spell.attainments.sympatheticRange && !this.isAdvanced(\"range\")) {\n        // debounce(() => {\n        //   this.spell.attainments.sympatheticRange = false\n        //   Toast.create(\n        //     \"Sympathetic Range attainment requires advanced Range. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n\n      // temporal sympathy requires advanced\n      if (this.spell.attainments.temporalSympathy && !this.isAdvanced(\"range\")) {\n        // debounce(() => {\n        //   this.spell.attainments.temporalSympathy = false\n        //   Toast.create(\n        //     \"Temporal Sympathy attainment requires advanced Range. Deselecting attainment.\"\n        //   )\n        // })()\n      }\n    },\n    isUniqueYantraUsed(key) {\n      let yantra = this.yantras.get(key)\n\n      // ignore non-uniques\n      if (!yantra.unique) {\n        return false\n      }\n\n      // this version is used?\n      if (this.hasYantra(key)) {\n        return true\n      }\n\n      // there are multiple version of this yantra - check for others\n      if (key.indexOf(\"_\") !== -1) {\n        let baseKey = key.split(\"_\")[0]\n        if (this.spell.yantras.some((yantra) => yantra.yantraKey.indexOf(baseKey) === 0)) {\n          return true\n        }\n      }\n\n      return false\n    },\n    getYantraOptions(prefix) {\n      let options = []\n\n      for (let [key, yantra] of this.yantras) {\n        if (key[0] === prefix) {\n          // 'l', 'a', or 't'\n          // disabled?\n          let disabledWarning\n\n          if (key === \"a1\" && this.spell.isRote === false) {\n            disabledWarning = \"Only available when casting Rotes.\"\n          }\n\n          if (key === \"a2\" && !this.isConcentrationMantraAllowed) {\n            disabledWarning = \"Duration must be more than 1 turn to use concentration.\"\n          }\n\n          if (this.isUniqueYantraUsed(key)) {\n            disabledWarning = \"Only one of this Yantra may be used.\"\n          }\n\n          if (key === \"t1\" && this.isDedicatedToolYantraUsed) {\n            disabledWarning = \"A Dedicated Tool is already being used.\"\n          }\n\n          yantra.disabledWarning = disabledWarning\n\n          // add to options\n          options.push(yantra)\n        }\n      }\n\n      return options\n    },\n    hasYantra(key) {\n      return some(this.spell.yantras, [\"yantraKey\", key]) // `_.matchesProperty` iteratee shorthand.\n    },\n    addYantra(key) {\n      let yantra = this.yantras.get(key)\n\n      this.spell.yantras.push(yantra)\n    },\n    deleteYantra(key) {\n      let index = findIndex(this.spell.yantras, (yantra) => yantra.yantraKey === key)\n      this.spell.yantras.splice(index, 1)\n    },\n    updateYantraIsDedicatedTool(key, newValue) {\n      let index = findIndex(this.spell.yantras, (yantra) => yantra.yantraKey === key)\n      this.spell.yantras[index].isDedicatedTool = newValue\n    },\n    isEffectRestricted(item) {\n      let answer = false\n      if (item.requirement) {\n        item.requirement.forEach(i => {\n          if (this.caster.arcana[i.arcana].level < i.value) answer = true\n        })\n      }\n      return answer\n    },\n    isEffectAdded(item) {\n      const existing = this.spell.effects.findIndex(added => added.effect === item.effect);\n      return existing !== -1\n    },\n    // Effects\n    toggleEffect(item) {\n      if (this.isEffectAdded(item)) {\n        this.spell.effects.splice(this.spell.effects.findIndex(added => added.effect === item.effect), 1)\n      } else {\n        this.spell.effects.push(item)\n      }\n    },\n    // Spell Stuff\n    getSpellWithSummary(spell) {\n      const item = clone(spell)\n      const itemCastingSummary = []\n      if (item.isRote) itemCastingSummary.push(\"Rote\")\n      if (item.isPraxis) itemCastingSummary.push(\"Praxis\")\n      itemCastingSummary.push(`Reach ${this.usedReach}/${this.freeReach}`)\n      itemCastingSummary.push(`Dice Pool ${this.dicePool}`)\n      itemCastingSummary.push(`Mana ${this.totalMana}`)\n      itemCastingSummary.push(`Paradox ${this.paradoxDice}`)\n      const itemFactorSummary = [];\n      itemFactorSummary.push(`${this.potencySummary} potency`)\n      itemFactorSummary.push(`${this.durationSummary} duration`)\n      itemFactorSummary.push(`${this.castingTimeSummary} casting time`)\n      itemFactorSummary.push(`${this.rangeSummary} range`)\n      itemFactorSummary.push(`${this.scaleSummary}`)\n      const itemEffectSummary = item.effects.map(effect => effect.effect);\n      if (item.spendWillpower) itemEffectSummary.unshift(\"Willpower spent.\")\n      const itemYantraSummary = item.yantras.map(yantra => yantra.name);\n      item.id = new Date().getTime()\n      item.castingSummary = itemCastingSummary.join(\", \")\n      item.factorSummary = itemFactorSummary.join(\", \")\n      item.effectSummary = itemEffectSummary.join(\" \")\n      item.yantraSummary = itemYantraSummary.join(\", \")\n      item.actionSummary = { text: this.dicePoolSummary, dice: this.dicePool }\n      return item\n    },\n    putSpellMacroInClipboard(spell) {\n      const out = [];\n      out.push(\"&{template:default}\");\n      out.push(`{{name=**${spell.name}** (${spell.primaryArcana.arcana} ${Array.from({ length: spell.primaryArcana.level }, v => \"&bull;\").join(\"\")})}}`)\n      out.push(`{{casting=${spell.castingSummary}}}`)\n      out.push(`{{factors=${spell.factorSummary}}}`)\n      out.push(`{{effects=${spell.effectSummary || \"None\"}}}`)\n      out.push(`{{yantras=${spell.yantraSummary || \"None\"}}}`)\n      out.push(`{{=[Roll ${spell.actionSummary.text} to cast](!&#13;&#91;[&#63;{Number of dice|${spell.actionSummary.dice}}d10>8!>&#63;{Explodes on|10}]&#93; Successes)}}`);\n      const text = out.join(\" \");\n      navigator.clipboard.writeText(text).then(() => {\n        this.message.info(`${spell.name} was copied to clipboard`)\n      });\n    },\n    copyActiveSpell() {\n      const spell = this.getSpellWithSummary(this.spell)\n      this.putSpellMacroInClipboard(spell)\n    },\n    copySavedSpell(spell) {\n      this.putSpellMacroInClipboard(spell)\n    },\n    removeSpell(spell) {\n      let index = findIndex(this.saved, (item) => item.id === spell.id)\n      this.saved.splice(index, 1)\n      this.message.error(`${spell.name} was removed`)\n    },\n    loadSpell(spell) {\n      this.spell = spell\n      this.message.success(`${spell.name} was loaded`)\n    },\n    saveActiveSpell() {\n      const spell = this.getSpellWithSummary(this.spell)\n      this.saved.push(spell)\n      this.message.success(`${spell.name} was saved`)\n    },\n    reset() {\n      this.spell = clone(defaultSpell)\n      this.paradox = clone(defaultParadox)\n      this.conditions = clone(defaultConditions)\n      this.message.warning(\"Spell was reset\")\n    },\n    log(text) {\n      console.log(text)\n    },\n  },\n  mounted() {\n    if (localStorage.getItem(\"caster\")) {\n      try {\n        this.caster = JSON.parse(localStorage.getItem(\"caster\"))\n      } catch (err) {\n        console.error(err)\n        localStorage.removeItem(\"caster\")\n      }\n    }\n    if (localStorage.getItem(\"saved\")) {\n      try {\n        this.saved = JSON.parse(localStorage.getItem(\"saved\"))\n      } catch (err) {\n        console.error(err)\n        localStorage.removeItem(\"saved\")\n      }\n    }\n    if (localStorage.getItem(\"dark\")) {\n      try {\n        this.dark = JSON.parse(localStorage.getItem(\"dark\"))\n        this.setDark(this.dark)\n      } catch (err) {\n        console.error(err)\n        localStorage.removeItem(\"dark\")\n      }\n    }\n  },\n}\n</script>\n\n<style>\nhtml {\n  height: 100%;\n}\nbody {\n  height: 100%;\n  overflow: hidden;\n}\n.n-tabs .n-tabs-pane-wrapper {\n  overflow: visible;\n}\n.n-layout {\n  height: 100vh;\n}\n@media only screen\n  and (min-device-width: 320px)\n  and (max-device-width: 600px)\n  and (-webkit-min-device-pixel-ratio: 2)\n  and (orientation: portrait) {\n  .n-layout {\n    height: -webkit-fill-available;\n  }\n}\n.n-tabs {\n  padding: 60px 10px 100px;\n  max-width: 600px;\n  margin: 0 auto;\n}\n.n-tabs .n-tabs-tab-pad {\n  width: 5px;\n}\n.n-tabs .n-tabs-tab {\n  padding: 10px;\n}\n.s-modal {\n  min-width: 400px;\n  max-width: 400px;\n  margin: 30px auto;\n}\n.s-table td {\n  vertical-align: middle;\n  line-height: 20px;\n}\n.e-table td {\n  vertical-align: top;\n  line-height: 19px;\n}\n.e-table td .n-switch {\n  vertical-align: top;\n}\n.n-card {\n  box-shadow: var(--n-box-shadow);\n}\n.n-card-header__extra {\n  flex: 1;\n  justify-content: flex-end;\n}\n.n-rate {\n  vertical-align: middle;\n}\n.n-rate__item svg circle {\n  stroke: var(--n-text-color);\n}\n.n-rate__item--active svg circle {\n  fill: var(--n-text-color);\n  stroke: var(--n-text-color);\n}\n.n-tabs-nav__suffix .n-switch.n-switch--active .n-switch__rail {\n    /* background-color: #f2c97d; */\n}\n.quick {\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 10;\n}\n.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n  position: fixed !important;\n  z-index: 10;\n}\n#spellAffix {\n  margin-bottom: -48px;\n  width: 100%;\n  max-width: 580px;\n}\n@media only screen\n  and (max-width: 600px) {\n  #spellAffix {\n    max-width: 100%;\n  }\n  #spellAffix.n-affix.n-affix--affixed.n-affix--absolute-positioned {\n    max-width: calc(100% - 20px);\n  }\n}\n.spellSummary {\n  height: 45px;\n}\n.spellSummary .n-card__content  {\n  padding: 10px !important;\n}\n.quick .n-card__content {\n  max-width: 600px;\n  width: 100%;\n  margin: 0 auto;\n  padding: 10px !important;\n}\n#spellOptions {\n  position: fixed;\n  right: 10px;\n  bottom: 10px;\n  border-radius: 70px;\n  width: auto;\n}\n#spellOptions .n-card__content {\n  padding: 10px !important;\n}\n</style>\n"],"names":[],"version":3,"file":"index.1cf4b200.css.map"}